{
  "name": "M3U Playlist Proxy Endpoints with Caching",
  "description": "Add two M3U playlist proxy endpoints to the existing Go server that fetch playlists from IPFS sources, rewrite acestream:// URLs to Acestream player URLs, and provide persistent caching with automatic expiration and refresh. The endpoints will serve cached versions when IPFS sources are unreachable, ensuring reliability.",
  "branchName": "feature/m3u-playlist-proxy-endpoints-with-caching",
  "userStories": [
    {
      "id": "US-001",
      "title": "Add configuration for cache and player URL",
      "description": "As a developer, I want to configure the cache directory, TTL, and Acestream player base URL via environment variables so that the deployment is flexible.",
      "acceptanceCriteria": [
        "Add `CACHE_DIR` environment variable with validation",
        "Add `CACHE_TTL` environment variable (duration format like \"1h\", \"30m\")",
        "Add `ACESTREAM_PLAYER_BASE_URL` environment variable",
        "Update `.env.example` with new variables",
        "Add configuration validation on server startup",
        "Return clear error if required env vars are missing"
      ],
      "priority": 1,
      "passes": true,
      "labels": [],
      "dependsOn": [],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-002",
      "title": "Implement persistent cache storage layer",
      "description": "As a system, I want to store fetched playlists to disk with metadata so that they can be served when IPFS is unavailable.",
      "acceptanceCriteria": [
        "Create cache storage interface with Get/Set/IsExpired methods",
        "Implement file-based cache storage in configured CACHE_DIR",
        "Store both playlist content and fetch timestamp",
        "Cache key should be derived from source URL",
        "Handle file system errors gracefully",
        "Ensure cache directory is created if it doesn't exist"
      ],
      "priority": 2,
      "passes": true,
      "labels": [],
      "dependsOn": [],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-003",
      "title": "Implement M3U fetching with cache fallback",
      "description": "As a system, I want to fetch M3U content from IPFS with cache fallback so that the service remains available during upstream failures.",
      "acceptanceCriteria": [
        "Create HTTP client with reasonable timeout (e.g., 10s)",
        "Fetch content from IPFS URL",
        "On success, update cache with fresh content",
        "On failure, check for cached version and serve if available",
        "Return 502 Bad Gateway only if no cache exists",
        "Log fetch attempts and cache hits/misses"
      ],
      "priority": 3,
      "passes": true,
      "labels": [],
      "dependsOn": [],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-004",
      "title": "Implement acestream:// URL rewriting",
      "description": "As a system, I want to rewrite acestream:// URLs to player-compatible format so that clients can play the streams.",
      "acceptanceCriteria": [
        "Parse M3U content line by line",
        "Identify lines starting with \"acestream://\"",
        "Extract stream ID from acestream:// URL",
        "Rewrite to `${ACESTREAM_PLAYER_BASE_URL}/ace/getstream?id={id}`",
        "Preserve all other lines unchanged (including #EXTINF metadata)",
        "Handle edge cases (malformed URLs, empty lines)"
      ],
      "priority": 4,
      "passes": true,
      "labels": [],
      "dependsOn": [],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-005",
      "title": "Implement cache expiration and refresh logic",
      "description": "As a system, I want to check cache expiration on each request and refresh if needed so that users get reasonably fresh content.",
      "acceptanceCriteria": [
        "On request, check if cached content exists and is fresh (within TTL)",
        "If cache is fresh, serve immediately",
        "If cache is expired, attempt to fetch new content",
        "If fetch succeeds, update cache and serve new content",
        "If fetch fails, serve stale cache with warning log",
        "TTL calculation based on file modification time + CACHE_TTL"
      ],
      "priority": 4,
      "passes": true,
      "labels": [],
      "dependsOn": [],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-006",
      "title": "Add /playlists/elcano.m3u endpoint",
      "description": "As a user, I want to access the Elcano playlist at /playlists/elcano.m3u so that I can use it in my media player.",
      "acceptanceCriteria": [
        "Register GET handler at `/playlists/elcano.m3u`",
        "Source URL: `https://ipfs.io/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes_acestream.m3u`",
        "Use fetch + cache + rewrite pipeline",
        "Return Content-Type: `audio/x-mpegurl` or `application/vnd.apple.mpegurl`",
        "Return 200 OK with playlist content",
        "Return 502 Bad Gateway if no cache and fetch fails"
      ],
      "priority": 4,
      "passes": true,
      "labels": [],
      "dependsOn": [],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-007",
      "title": "Add /playlists/newera.m3u endpoint",
      "description": "As a user, I want to access the NewEra playlist at /playlists/newera.m3u so that I can use it in my media player.",
      "acceptanceCriteria": [
        "Register GET handler at `/playlists/newera.m3u`",
        "Source URL: `https://ipfs.io/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_fuera_iptv.m3u`",
        "Use fetch + cache + rewrite pipeline",
        "Return Content-Type: `audio/x-mpegurl` or `application/vnd.apple.mpegurl`",
        "Return 200 OK with playlist content",
        "Return 502 Bad Gateway if no cache and fetch fails"
      ],
      "priority": 4,
      "passes": false,
      "labels": [],
      "dependsOn": []
    },
    {
      "id": "US-008",
      "title": "Add integration tests for endpoints",
      "description": "As a developer, I want integration tests that verify the complete flow so that I can ensure the feature works end-to-end.",
      "acceptanceCriteria": [
        "Test case: Fresh fetch from mock IPFS server",
        "Test case: Cache hit (serve from cache without fetch)",
        "Test case: Expired cache refresh",
        "Test case: IPFS failure with stale cache fallback",
        "Test case: URL rewriting produces correct output",
        "Verify Content-Type headers are correct",
        "Verify HTTP status codes for all scenarios"
      ],
      "priority": 4,
      "passes": false,
      "labels": [],
      "dependsOn": []
    }
  ],
  "metadata": {
    "createdAt": "2026-01-30T11:17:47.827Z",
    "version": "1.0.0",
    "sourcePrd": "prd.md",
    "updatedAt": "2026-01-30T11:36:05.613Z"
  }
}