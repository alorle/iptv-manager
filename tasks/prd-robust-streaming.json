{
  "name": "Sistema de Reproducción de Streams Robusto",
  "description": "Mejorar la robustez del sistema de reproducción/proxy de streams con reconexión automática, circuit breaker, health checks y métricas Prometheus",
  "branchName": "ralph/robust-stream-playback",
  "userStories": [
    {
      "id": "US-008",
      "title": "Configuración centralizada de resiliencia",
      "description": "Como operador, quiero todas las configuraciones de resiliencia documentadas y con defaults sensatos.",
      "acceptanceCriteria": [
        "Nuevas variables de entorno parseadas: RECONNECT_BUFFER_SIZE (default: 2MB), RECONNECT_MAX_BACKOFF (default: 30s), RECONNECT_INITIAL_BACKOFF (default: 500ms)",
        "Variables de circuit breaker parseadas: CB_FAILURE_THRESHOLD (default: 5), CB_TIMEOUT (default: 30s), CB_HALF_OPEN_REQUESTS (default: 1)",
        "Variables adicionales parseadas: HEALTH_CHECK_INTERVAL (default: 30s), LOG_LEVEL (default: INFO)",
        "Validación de configuración al inicio con errores claros si valores inválidos",
        "Estructura ResilienceConfig que agrupa todas las configuraciones",
        "Tests de parsing y validación de configuración",
        "go build ./... passes",
        "go test ./... passes",
        "go vet ./... passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "",
      "dependsOn": [],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-001",
      "title": "Aislar contexto de clientes del contexto de upstream",
      "description": "Como operador del sistema, quiero que la desconexión de un cliente no cancele la lectura del upstream, para que otros clientes del mismo stream no se vean afectados.",
      "acceptanceCriteria": [
        "El contexto del upstream es independiente del contexto de cada cliente (crear contexto separado para upstream)",
        "Cuando un cliente desconecta, solo se elimina ese cliente del stream sin afectar upstream",
        "El upstream continúa leyendo mientras haya al menos un cliente conectado",
        "Tests que verifican que desconectar cliente A no afecta a cliente B en el mismo stream",
        "go build ./... passes",
        "go test ./... passes",
        "go vet ./... passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-008"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-004",
      "title": "Implementar Circuit Breaker para Acestream Engine",
      "description": "Como operador, quiero un circuit breaker que proteja el Acestream Engine cuando está sobrecargado, para evitar cascadas de fallos.",
      "acceptanceCriteria": [
        "Crear paquete circuitbreaker con estados: CLOSED (normal), OPEN (bloqueando), HALF-OPEN (probando)",
        "Transición a OPEN después de N fallos consecutivos (usar CB_FAILURE_THRESHOLD de config)",
        "En estado OPEN, nuevas peticiones retornan error inmediatamente con mensaje descriptivo",
        "Transición a HALF-OPEN después de timeout (usar CB_TIMEOUT de config)",
        "En HALF-OPEN, permitir CB_HALF_OPEN_REQUESTS peticiones de prueba; éxito → CLOSED, fallo → OPEN",
        "Interfaz CircuitBreaker con métodos: Execute(func), State(), Reset()",
        "Tests para cada transición de estado del circuit breaker",
        "go build ./... passes",
        "go test ./... passes",
        "go vet ./... passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-008"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-002",
      "title": "Implementar reconexión automática de upstream",
      "description": "Como usuario, quiero que el sistema reconecte automáticamente cuando el upstream falla, para no perder el stream por errores transitorios.",
      "acceptanceCriteria": [
        "Cuando upstream.Read() retorna error (no EOF ni context.Canceled de cliente), se intenta reconexión",
        "Reintentos continúan mientras haya al menos un cliente conectado al stream",
        "Backoff exponencial usando RECONNECT_INITIAL_BACKOFF (500ms) hasta RECONNECT_MAX_BACKOFF (30s)",
        "Log de cada intento de reconexión con número de intento y tiempo de espera",
        "Si reconexión exitosa, se reanuda el fan-out a clientes sin interrupción",
        "Integrar con circuit breaker: no reintentar si CB está OPEN",
        "Tests unitarios para lógica de backoff y reconexión",
        "go build ./... passes",
        "go test ./... passes",
        "go vet ./... passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-001",
        "US-004"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-003",
      "title": "Buffer de resiliencia durante reconexión",
      "description": "Como usuario, quiero que durante la reconexión se use el buffer existente antes de pausar, para minimizar interrupciones visibles.",
      "acceptanceCriteria": [
        "Implementar buffer circular que almacena los últimos N bytes leídos del upstream",
        "Tamaño de buffer configurable vía RECONNECT_BUFFER_SIZE (default: 2MB)",
        "Durante reconexión, clientes nuevos que se conectan reciben datos del buffer primero",
        "Cuando buffer se agota durante reconexión, clientes entran en estado de espera (pausa sin error)",
        "Al reconectar exitosamente, reanudar envío normal a todos los clientes",
        "Tests que verifican comportamiento del buffer durante reconexión simulada",
        "go build ./... passes",
        "go test ./... passes",
        "go vet ./... passes"
      ],
      "priority": 5,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-002"
      ]
    },
    {
      "id": "US-005",
      "title": "Health checks periódicos al Acestream Engine",
      "description": "Como operador, quiero health checks periódicos al Engine para detectar problemas antes de que afecten a los streams activos.",
      "acceptanceCriteria": [
        "Identificar endpoint de health en Acestream Engine (probar /webui/api/service o similar)",
        "Goroutine que ejecuta health check cada HEALTH_CHECK_INTERVAL segundos",
        "Si health check falla, registrar fallo en circuit breaker (incrementar contador de fallos)",
        "Log de resultados: nivel DEBUG para éxitos, WARN para fallos",
        "Health check se deshabilita si HEALTH_CHECK_INTERVAL=0",
        "Método para obtener último estado de health check",
        "Tests para lógica de health check con mock del Engine",
        "go build ./... passes",
        "go test ./... passes",
        "go vet ./... passes"
      ],
      "priority": 6,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-004"
      ]
    },
    {
      "id": "US-007",
      "title": "Logging estructurado para eventos de resiliencia",
      "description": "Como operador, quiero logs detallados de eventos de reconexión y circuit breaker para facilitar debugging.",
      "acceptanceCriteria": [
        "Logs incluyen: timestamp, contentID (cuando aplica), tipo de evento, detalles relevantes",
        "Evento: Intento de reconexión (INFO) - incluye número de intento, backoff, contentID",
        "Evento: Reconexión exitosa (INFO) - incluye tiempo total de interrupción, contentID",
        "Evento: Reconexión fallida definitiva (ERROR) - incluye razón, contentID, número de intentos",
        "Evento: Cambio de estado de circuit breaker (WARN) - incluye estado anterior y nuevo",
        "Evento: Health check fallido (WARN) - incluye error recibido",
        "Nivel de log configurable vía LOG_LEVEL (DEBUG, INFO, WARN, ERROR)",
        "Tests que verifican que eventos generan logs con nivel apropiado",
        "go build ./... passes",
        "go test ./... passes",
        "go vet ./... passes"
      ],
      "priority": 7,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-002",
        "US-004"
      ]
    },
    {
      "id": "US-006",
      "title": "Endpoint de métricas Prometheus",
      "description": "Como operador, quiero exponer métricas en formato Prometheus para monitorizar el estado del sistema.",
      "acceptanceCriteria": [
        "Nuevo endpoint GET /metrics que retorna métricas en formato Prometheus text",
        "Métrica gauge: iptv_streams_active - número de streams activos",
        "Métrica gauge: iptv_clients_connected - número total de clientes conectados",
        "Métrica counter: iptv_upstream_reconnections_total - reconexiones totales (label: content_id)",
        "Métrica counter: iptv_upstream_errors_total - errores de upstream (labels: content_id, error_type)",
        "Métrica gauge: iptv_circuit_breaker_state - estado actual (0=closed, 1=open, 2=half-open)",
        "Métrica counter: iptv_circuit_breaker_trips_total - veces que CB pasó a OPEN",
        "Métrica counter: iptv_health_check_failures_total - fallos de health check",
        "Usar github.com/prometheus/client_golang para registro de métricas",
        "Tests que verifican formato correcto de salida en /metrics",
        "go build ./... passes",
        "go test ./... passes",
        "go vet ./... passes"
      ],
      "priority": 8,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-001",
        "US-004",
        "US-005"
      ]
    }
  ],
  "metadata": {
    "updatedAt": "2026-01-31T18:25:28.962Z"
  }
}