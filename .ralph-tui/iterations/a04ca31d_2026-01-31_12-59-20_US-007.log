# Iteration 7 Log

## Metadata

- **Task ID**: US-007
- **Task Title**: Add integration tests for unified playlist endpoint
- **Description**: As a developer, I want integration tests so that the endpoint behavior is verified.
- **Status**: completed
- **Task Completed**: Yes
- **Promise Detected**: Yes
- **Started At**: 2026-01-31T11:59:20.733Z
- **Ended At**: 2026-01-31T12:02:29.121Z
- **Duration**: 3m 8s
- **Agent**: claude
- **Sandbox Mode**: auto
- **Sandbox Network**: Enabled
--- RAW OUTPUT ---
{"type":"system","subtype":"init","cwd":"/home/alorle/gh/alorle/iptv-manager","session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","mcp__sequential-thinking__sequentialthinking","mcp__context7__resolve-library-id","mcp__context7__query-docs","mcp__chrome-devtools__click","mcp__chrome-devtools__close_page","mcp__chrome-devtools__drag","mcp__chrome-devtools__emulate","mcp__chrome-devtools__evaluate_script","mcp__chrome-devtools__fill","mcp__chrome-devtools__fill_form","mcp__chrome-devtools__get_console_message","mcp__chrome-devtools__get_network_request","mcp__chrome-devtools__handle_dialog","mcp__chrome-devtools__hover","mcp__chrome-devtools__list_console_messages","mcp__chrome-devtools__list_network_requests","mcp__chrome-devtools__list_pages","mcp__chrome-devtools__navigate_page","mcp__chrome-devtools__new_page","mcp__chrome-devtools__performance_analyze_insight","mcp__chrome-devtools__performance_start_trace","mcp__chrome-devtools__performance_stop_trace","mcp__chrome-devtools__press_key","mcp__chrome-devtools__resize_page","mcp__chrome-devtools__select_page","mcp__chrome-devtools__take_screenshot","mcp__chrome-devtools__take_snapshot","mcp__chrome-devtools__upload_file","mcp__chrome-devtools__wait_for","mcp__playwright__browser_close","mcp__playwright__browser_resize","mcp__playwright__browser_console_messages","mcp__playwright__browser_handle_dialog","mcp__playwright__browser_evaluate","mcp__playwright__browser_file_upload","mcp__playwright__browser_fill_form","mcp__playwright__browser_install","mcp__playwright__browser_press_key","mcp__playwright__browser_type","mcp__playwright__browser_navigate","mcp__playwright__browser_navigate_back","mcp__playwright__browser_network_requests","mcp__playwright__browser_run_code","mcp__playwright__browser_take_screenshot","mcp__playwright__browser_snapshot","mcp__playwright__browser_click","mcp__playwright__browser_drag","mcp__playwright__browser_hover","mcp__playwright__browser_select_option","mcp__playwright__browser_tabs","mcp__playwright__browser_wait_for","mcp__github__add_comment_to_pending_review","mcp__github__add_issue_comment","mcp__github__assign_copilot_to_issue","mcp__github__create_branch","mcp__github__create_or_update_file","mcp__github__create_pull_request","mcp__github__create_repository","mcp__github__delete_file","mcp__github__fork_repository","mcp__github__get_commit","mcp__github__get_file_contents","mcp__github__get_label","mcp__github__get_latest_release","mcp__github__get_me","mcp__github__get_release_by_tag","mcp__github__get_tag","mcp__github__get_team_members","mcp__github__get_teams","mcp__github__issue_read","mcp__github__issue_write","mcp__github__list_branches","mcp__github__list_commits","mcp__github__list_issue_types","mcp__github__list_issues","mcp__github__list_pull_requests","mcp__github__list_releases","mcp__github__list_tags","mcp__github__merge_pull_request","mcp__github__pull_request_read","mcp__github__pull_request_review_write","mcp__github__push_files","mcp__github__request_copilot_review","mcp__github__search_code","mcp__github__search_issues","mcp__github__search_pull_requests","mcp__github__search_repositories","mcp__github__search_users","mcp__github__sub_issue_write","mcp__github__update_pull_request","mcp__github__update_pull_request_branch","ListMcpResourcesTool","ReadMcpResourceTool"],"mcp_servers":[{"name":"sequential-thinking","status":"connected"},{"name":"context7","status":"connected"},{"name":"chrome-devtools","status":"connected"},{"name":"playwright","status":"connected"},{"name":"github","status":"connected"}],"model":"claude-sonnet-4-5-20250929","permissionMode":"bypassPermissions","slash_commands":["keybindings-help","ralph-tui-create-json","vite","vercel-react-best-practices","vitest","ralph","vercel-react-native-skills","frontend-design","vercel-composition-patterns","ralph-tui-prd","ralph-tui-create-beads-rust","web-design-guidelines","browser-use","ralph-tui-create-beads","web-artifacts-builder","prd","find-skills","skill-creator","compact","context","cost","init","pr-comments","release-notes","review","security-review","mcp__github__AssignCodingAgent","mcp__github__issue_to_fix_workflow"],"apiKeySource":"apiKeyHelper","claude_code_version":"2.1.23","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan"],"skills":["keybindings-help","ralph-tui-create-json","vite","vercel-react-best-practices","vitest","ralph","vercel-react-native-skills","frontend-design","vercel-composition-patterns","ralph-tui-prd","ralph-tui-create-beads-rust","web-design-guidelines","browser-use","ralph-tui-create-beads","web-artifacts-builder","prd","find-skills","skill-creator"],"plugins":[],"uuid":"fd8b972f-9443-4918-8ff0-cfc01c0e1ba3"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01HXHiVV78z4bcBpqmX4zTNb","type":"message","role":"assistant","content":[{"type":"text","text":"I'll implement comprehensive integration tests for the unified playlist endpoint. Let me start by examining the existing test patterns and the endpoint implementation."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":5357,"cache_read_input_tokens":35612,"cache_creation":{"ephemeral_5m_input_tokens":5357,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"bec24f4b-9f0b-479a-93b1-d6743b4ce8c0"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01HXHiVV78z4bcBpqmX4zTNb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016VLj78oz7AFFDMZgp3Fchq","name":"TodoWrite","input":{"todos":[{"content":"Examine existing test patterns in main_test.go","activeForm":"Examining existing test patterns in main_test.go","status":"in_progress"},{"content":"Review the unified playlist endpoint implementation","activeForm":"Reviewing the unified playlist endpoint implementation","status":"pending"},{"content":"Write integration tests covering all acceptance criteria","activeForm":"Writing integration tests covering all acceptance criteria","status":"pending"},{"content":"Run go build ./... to verify build","activeForm":"Running go build ./... to verify build","status":"pending"},{"content":"Run go test ./... to verify all tests pass","activeForm":"Running go test ./... to verify all tests pass","status":"pending"},{"content":"Commit changes with feat message","activeForm":"Committing changes with feat message","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":5357,"cache_read_input_tokens":35612,"cache_creation":{"ephemeral_5m_input_tokens":5357,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"96490f42-9948-4f37-a968-dfe2608b45dd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016VLj78oz7AFFDMZgp3Fchq","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"65cc37f4-41af-422a-80dc-3999ef7554a0","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Examine existing test patterns in main_test.go","status":"in_progress","activeForm":"Examining existing test patterns in main_test.go"},{"content":"Review the unified playlist endpoint implementation","status":"pending","activeForm":"Reviewing the unified playlist endpoint implementation"},{"content":"Write integration tests covering all acceptance criteria","status":"pending","activeForm":"Writing integration tests covering all acceptance criteria"},{"content":"Run go build ./... to verify build","status":"pending","activeForm":"Running go build ./... to verify build"},{"content":"Run go test ./... to verify all tests pass","status":"pending","activeForm":"Running go test ./... to verify all tests pass"},{"content":"Commit changes with feat message","status":"pending","activeForm":"Committing changes with feat message"}]}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012FUSawJufWv1aA5EtXXewM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UbeMqj8fWdb4Zcz2tXp8H5","name":"Read","input":{"file_path":"/home/alorle/gh/alorle/iptv-manager/main_test.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":326,"cache_read_input_tokens":40969,"cache_creation":{"ephemeral_5m_input_tokens":326,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"c0c8e7ac-ac67-4909-91da-7aca805a5f76"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UbeMqj8fWdb4Zcz2tXp8H5","type":"tool_result","content":"     1→package main\n     2→\n     3→import (\n     4→\t\"fmt\"\n     5→\t\"net/http\"\n     6→\t\"net/http/httptest\"\n     7→\t\"os\"\n     8→\t\"path/filepath\"\n     9→\t\"strings\"\n    10→\t\"testing\"\n    11→\t\"time\"\n    12→\n    13→\t\"github.com/alorle/iptv-manager/cache\"\n    14→\t\"github.com/alorle/iptv-manager/fetcher\"\n    15→\t\"github.com/alorle/iptv-manager/rewriter\"\n    16→)\n    17→\n    18→const (\n    19→\tmockM3UContent = `#EXTM3U\n    20→#EXTINF:-1 tvg-id=\"test1\" tvg-name=\"Test Channel 1\" tvg-logo=\"http://example.com/logo1.png\" group-title=\"Sports\",Test Channel 1\n    21→acestream://0000111122223333444455556666777788889999\n    22→#EXTINF:-1 tvg-id=\"test2\" tvg-name=\"Test Channel 2\" group-title=\"Movies\",Test Channel 2\n    23→http://example.com/stream.m3u8\n    24→#EXTINF:-1 tvg-id=\"test3\" tvg-name=\"Test Channel 3\",Test Channel 3\n    25→acestream://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n    26→`\n    27→)\n    28→\n    29→// setupTestEnvironment creates a temporary directory and returns cleanup function\n    30→func setupTestEnvironment(t *testing.T) (string, func()) {\n    31→\tt.Helper()\n    32→\ttempDir := t.TempDir()\n    33→\treturn tempDir, func() {}\n    34→}\n    35→\n    36→// createMockIPFSServer creates an HTTP server that simulates IPFS behavior\n    37→func createMockIPFSServer(t *testing.T, shouldFail bool, content string) *httptest.Server {\n    38→\tt.Helper()\n    39→\treturn httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    40→\t\tif shouldFail {\n    41→\t\t\tw.WriteHeader(http.StatusServiceUnavailable)\n    42→\t\t\tw.Write([]byte(\"IPFS node unavailable\"))\n    43→\t\t\treturn\n    44→\t\t}\n    45→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n    46→\t\tw.WriteHeader(http.StatusOK)\n    47→\t\tw.Write([]byte(content))\n    48→\t}))\n    49→}\n    50→\n    51→// TestIntegration_FreshFetchFromMockIPFS tests fetching fresh content from mock IPFS server\n    52→func TestIntegration_FreshFetchFromMockIPFS(t *testing.T) {\n    53→\t// Setup test environment\n    54→\tcacheDir, cleanup := setupTestEnvironment(t)\n    55→\tdefer cleanup()\n    56→\n    57→\t// Create mock IPFS server\n    58→\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n    59→\tdefer mockServer.Close()\n    60→\n    61→\t// Initialize components\n    62→\tstorage, err := cache.NewFileStorage(cacheDir)\n    63→\tif err != nil {\n    64→\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n    65→\t}\n    66→\n    67→\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n    68→\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n    69→\n    70→\t// Create test server\n    71→\tmux := http.NewServeMux()\n    72→\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n    73→\t\tif r.Method != http.MethodGet {\n    74→\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n    75→\t\t\treturn\n    76→\t\t}\n    77→\n    78→\t\tcontent, fromCache, stale, err := fetch.FetchWithCache(mockServer.URL)\n    79→\t\tif err != nil {\n    80→\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n    81→\t\t\treturn\n    82→\t\t}\n    83→\n    84→\t\tif fromCache {\n    85→\t\t\tt.Error(\"Expected fresh fetch, but got cached content\")\n    86→\t\t}\n    87→\t\tif stale {\n    88→\t\t\tt.Error(\"Expected fresh content, but got stale cache\")\n    89→\t\t}\n    90→\n    91→\t\trewrittenContent := rw.RewriteM3U(content)\n    92→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n    93→\t\tw.WriteHeader(http.StatusOK)\n    94→\t\tw.Write(rewrittenContent)\n    95→\t})\n    96→\n    97→\ttestServer := httptest.NewServer(mux)\n    98→\tdefer testServer.Close()\n    99→\n   100→\t// Make request\n   101→\tresp, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n   102→\tif err != nil {\n   103→\t\tt.Fatalf(\"Failed to make request: %v\", err)\n   104→\t}\n   105→\tdefer resp.Body.Close()\n   106→\n   107→\t// Verify HTTP status code\n   108→\tif resp.StatusCode != http.StatusOK {\n   109→\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n   110→\t}\n   111→\n   112→\t// Verify Content-Type header\n   113→\tcontentType := resp.Header.Get(\"Content-Type\")\n   114→\tif contentType != \"audio/x-mpegurl\" {\n   115→\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n   116→\t}\n   117→\n   118→\t// Read and verify response body\n   119→\tbody := make([]byte, 4096)\n   120→\tn, _ := resp.Body.Read(body)\n   121→\tbodyStr := string(body[:n])\n   122→\n   123→\t// Verify URL rewriting occurred\n   124→\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=0000111122223333444455556666777788889999\") {\n   125→\t\tt.Error(\"Expected first acestream URL to be rewritten\")\n   126→\t}\n   127→\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") {\n   128→\t\tt.Error(\"Expected second acestream URL to be rewritten\")\n   129→\t}\n   130→\tif !strings.Contains(bodyStr, \"http://example.com/stream.m3u8\") {\n   131→\t\tt.Error(\"Expected HTTP URL to be preserved\")\n   132→\t}\n   133→\tif !strings.Contains(bodyStr, \"#EXTINF\") {\n   134→\t\tt.Error(\"Expected metadata to be preserved\")\n   135→\t}\n   136→}\n   137→\n   138→// TestIntegration_CacheHit tests serving content from fresh cache\n   139→func TestIntegration_CacheHit(t *testing.T) {\n   140→\t// Setup test environment\n   141→\tcacheDir, cleanup := setupTestEnvironment(t)\n   142→\tdefer cleanup()\n   143→\n   144→\trequestCount := 0\n   145→\t// Create mock IPFS server that counts requests\n   146→\tmockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n   147→\t\trequestCount++\n   148→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   149→\t\tw.WriteHeader(http.StatusOK)\n   150→\t\tw.Write([]byte(mockM3UContent))\n   151→\t}))\n   152→\tdefer mockServer.Close()\n   153→\n   154→\t// Initialize components\n   155→\tstorage, err := cache.NewFileStorage(cacheDir)\n   156→\tif err != nil {\n   157→\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n   158→\t}\n   159→\n   160→\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n   161→\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n   162→\n   163→\t// Create test server\n   164→\tmux := http.NewServeMux()\n   165→\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n   166→\t\tif r.Method != http.MethodGet {\n   167→\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n   168→\t\t\treturn\n   169→\t\t}\n   170→\n   171→\t\tcontent, fromCache, stale, err := fetch.FetchWithCache(mockServer.URL)\n   172→\t\tif err != nil {\n   173→\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n   174→\t\t\treturn\n   175→\t\t}\n   176→\n   177→\t\trewrittenContent := rw.RewriteM3U(content)\n   178→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   179→\t\tw.WriteHeader(http.StatusOK)\n   180→\t\tw.Write(rewrittenContent)\n   181→\n   182→\t\t// Store cache status for verification\n   183→\t\tw.Header().Set(\"X-From-Cache\", fmt.Sprintf(\"%v\", fromCache))\n   184→\t\tw.Header().Set(\"X-Stale\", fmt.Sprintf(\"%v\", stale))\n   185→\t})\n   186→\n   187→\ttestServer := httptest.NewServer(mux)\n   188→\tdefer testServer.Close()\n   189→\n   190→\t// First request - should fetch from IPFS\n   191→\tresp1, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n   192→\tif err != nil {\n   193→\t\tt.Fatalf(\"Failed to make first request: %v\", err)\n   194→\t}\n   195→\tresp1.Body.Close()\n   196→\n   197→\tif requestCount != 1 {\n   198→\t\tt.Errorf(\"Expected 1 IPFS request after first fetch, got %d\", requestCount)\n   199→\t}\n   200→\n   201→\t// Second request - should serve from cache\n   202→\tresp2, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n   203→\tif err != nil {\n   204→\t\tt.Fatalf(\"Failed to make second request: %v\", err)\n   205→\t}\n   206→\tdefer resp2.Body.Close()\n   207→\n   208→\t// Verify no additional IPFS requests were made\n   209→\tif requestCount != 1 {\n   210→\t\tt.Errorf(\"Expected 1 IPFS request after cache hit, got %d\", requestCount)\n   211→\t}\n   212→\n   213→\t// Verify HTTP status code\n   214→\tif resp2.StatusCode != http.StatusOK {\n   215→\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp2.StatusCode)\n   216→\t}\n   217→\n   218→\t// Verify Content-Type header\n   219→\tcontentType := resp2.Header.Get(\"Content-Type\")\n   220→\tif contentType != \"audio/x-mpegurl\" {\n   221→\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n   222→\t}\n   223→\n   224→\t// Read response body\n   225→\tbody := make([]byte, 4096)\n   226→\tn, _ := resp2.Body.Read(body)\n   227→\tbodyStr := string(body[:n])\n   228→\n   229→\t// Verify URL rewriting still works\n   230→\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=0000111122223333444455556666777788889999\") {\n   231→\t\tt.Error(\"Expected acestream URL to be rewritten from cache\")\n   232→\t}\n   233→}\n   234→\n   235→// TestIntegration_ExpiredCacheRefresh tests cache refresh when TTL expires\n   236→func TestIntegration_ExpiredCacheRefresh(t *testing.T) {\n   237→\t// Setup test environment\n   238→\tcacheDir, cleanup := setupTestEnvironment(t)\n   239→\tdefer cleanup()\n   240→\n   241→\trequestCount := 0\n   242→\t// Create mock IPFS server\n   243→\tmockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n   244→\t\trequestCount++\n   245→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   246→\t\tw.WriteHeader(http.StatusOK)\n   247→\t\t// Send different content on second request\n   248→\t\tif requestCount == 1 {\n   249→\t\t\tw.Write([]byte(mockM3UContent))\n   250→\t\t} else {\n   251→\t\t\tw.Write([]byte(\"#EXTM3U\\n#EXTINF:-1,Updated Channel\\nacestream://bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"))\n   252→\t\t}\n   253→\t}))\n   254→\tdefer mockServer.Close()\n   255→\n   256→\t// Initialize components with very short TTL\n   257→\tstorage, err := cache.NewFileStorage(cacheDir)\n   258→\tif err != nil {\n   259→\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n   260→\t}\n   261→\n   262→\tfetch := fetcher.New(5*time.Second, storage, 100*time.Millisecond) // 100ms TTL\n   263→\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n   264→\n   265→\t// Create test server\n   266→\tmux := http.NewServeMux()\n   267→\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n   268→\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n   269→\t\tif err != nil {\n   270→\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n   271→\t\t\treturn\n   272→\t\t}\n   273→\n   274→\t\trewrittenContent := rw.RewriteM3U(content)\n   275→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   276→\t\tw.WriteHeader(http.StatusOK)\n   277→\t\tw.Write(rewrittenContent)\n   278→\t})\n   279→\n   280→\ttestServer := httptest.NewServer(mux)\n   281→\tdefer testServer.Close()\n   282→\n   283→\t// First request - should fetch from IPFS\n   284→\tresp1, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n   285→\tif err != nil {\n   286→\t\tt.Fatalf(\"Failed to make first request: %v\", err)\n   287→\t}\n   288→\tbody1 := make([]byte, 4096)\n   289→\tn1, _ := resp1.Body.Read(body1)\n   290→\tresp1.Body.Close()\n   291→\n   292→\tif requestCount != 1 {\n   293→\t\tt.Errorf(\"Expected 1 IPFS request, got %d\", requestCount)\n   294→\t}\n   295→\n   296→\t// Wait for cache to expire\n   297→\ttime.Sleep(150 * time.Millisecond)\n   298→\n   299→\t// Second request - should refresh cache\n   300→\tresp2, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n   301→\tif err != nil {\n   302→\t\tt.Fatalf(\"Failed to make second request: %v\", err)\n   303→\t}\n   304→\tbody2 := make([]byte, 4096)\n   305→\tn2, _ := resp2.Body.Read(body2)\n   306→\tresp2.Body.Close()\n   307→\n   308→\tif requestCount != 2 {\n   309→\t\tt.Errorf(\"Expected 2 IPFS requests after cache expiration, got %d\", requestCount)\n   310→\t}\n   311→\n   312→\t// Verify HTTP status code\n   313→\tif resp2.StatusCode != http.StatusOK {\n   314→\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp2.StatusCode)\n   315→\t}\n   316→\n   317→\t// Verify Content-Type header\n   318→\tcontentType := resp2.Header.Get(\"Content-Type\")\n   319→\tif contentType != \"audio/x-mpegurl\" {\n   320→\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n   321→\t}\n   322→\n   323→\t// Verify content changed (cache was refreshed)\n   324→\tbodyStr1 := string(body1[:n1])\n   325→\tbodyStr2 := string(body2[:n2])\n   326→\n   327→\tif !strings.Contains(bodyStr2, \"Updated Channel\") {\n   328→\t\tt.Error(\"Expected refreshed content with 'Updated Channel'\")\n   329→\t}\n   330→\tif !strings.Contains(bodyStr2, \"http://127.0.0.1:6878/ace/getstream?id=bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\") {\n   331→\t\tt.Error(\"Expected refreshed content with rewritten URL\")\n   332→\t}\n   333→\tif bodyStr1 == bodyStr2 {\n   334→\t\tt.Error(\"Expected different content after cache refresh\")\n   335→\t}\n   336→}\n   337→\n   338→// TestIntegration_IPFSFailureWithStaleCacheFallback tests serving stale cache when IPFS fails\n   339→func TestIntegration_IPFSFailureWithStaleCacheFallback(t *testing.T) {\n   340→\t// Setup test environment\n   341→\tcacheDir, cleanup := setupTestEnvironment(t)\n   342→\tdefer cleanup()\n   343→\n   344→\tipfsAvailable := true\n   345→\t// Create mock IPFS server that can be toggled\n   346→\tmockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n   347→\t\tif !ipfsAvailable {\n   348→\t\t\tw.WriteHeader(http.StatusServiceUnavailable)\n   349→\t\t\tw.Write([]byte(\"IPFS node unavailable\"))\n   350→\t\t\treturn\n   351→\t\t}\n   352→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   353→\t\tw.WriteHeader(http.StatusOK)\n   354→\t\tw.Write([]byte(mockM3UContent))\n   355→\t}))\n   356→\tdefer mockServer.Close()\n   357→\n   358→\t// Initialize components with short TTL\n   359→\tstorage, err := cache.NewFileStorage(cacheDir)\n   360→\tif err != nil {\n   361→\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n   362→\t}\n   363→\n   364→\tfetch := fetcher.New(5*time.Second, storage, 100*time.Millisecond)\n   365→\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n   366→\n   367→\t// Create test server\n   368→\tmux := http.NewServeMux()\n   369→\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n   370→\t\tcontent, fromCache, stale, err := fetch.FetchWithCache(mockServer.URL)\n   371→\t\tif err != nil {\n   372→\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n   373→\t\t\treturn\n   374→\t\t}\n   375→\n   376→\t\trewrittenContent := rw.RewriteM3U(content)\n   377→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   378→\t\tw.Header().Set(\"X-From-Cache\", fmt.Sprintf(\"%v\", fromCache))\n   379→\t\tw.Header().Set(\"X-Stale\", fmt.Sprintf(\"%v\", stale))\n   380→\t\tw.WriteHeader(http.StatusOK)\n   381→\t\tw.Write(rewrittenContent)\n   382→\t})\n   383→\n   384→\ttestServer := httptest.NewServer(mux)\n   385→\tdefer testServer.Close()\n   386→\n   387→\t// First request - populate cache\n   388→\tresp1, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n   389→\tif err != nil {\n   390→\t\tt.Fatalf(\"Failed to make first request: %v\", err)\n   391→\t}\n   392→\tresp1.Body.Close()\n   393→\n   394→\t// Wait for cache to expire\n   395→\ttime.Sleep(150 * time.Millisecond)\n   396→\n   397→\t// Make IPFS unavailable\n   398→\tipfsAvailable = false\n   399→\n   400→\t// Second request - should serve stale cache\n   401→\tresp2, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n   402→\tif err != nil {\n   403→\t\tt.Fatalf(\"Failed to make second request: %v\", err)\n   404→\t}\n   405→\tdefer resp2.Body.Close()\n   406→\n   407→\t// Verify HTTP status code (should still be OK)\n   408→\tif resp2.StatusCode != http.StatusOK {\n   409→\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp2.StatusCode)\n   410→\t}\n   411→\n   412→\t// Verify Content-Type header\n   413→\tcontentType := resp2.Header.Get(\"Content-Type\")\n   414→\tif contentType != \"audio/x-mpegurl\" {\n   415→\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n   416→\t}\n   417→\n   418→\t// Read response body\n   419→\tbody := make([]byte, 4096)\n   420→\tn, _ := resp2.Body.Read(body)\n   421→\tbodyStr := string(body[:n])\n   422→\n   423→\t// Verify we got stale cache content (original content should be present)\n   424→\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=0000111122223333444455556666777788889999\") {\n   425→\t\tt.Error(\"Expected stale cache content with rewritten URL\")\n   426→\t}\n   427→\tif !strings.Contains(bodyStr, \"Test Channel 1\") {\n   428→\t\tt.Error(\"Expected stale cache content with original metadata\")\n   429→\t}\n   430→}\n   431→\n   432→// TestIntegration_URLRewritingOutput tests that URL rewriting produces correct output\n   433→func TestIntegration_URLRewritingOutput(t *testing.T) {\n   434→\t// Setup test environment\n   435→\tcacheDir, cleanup := setupTestEnvironment(t)\n   436→\tdefer cleanup()\n   437→\n   438→\t// Create mock IPFS server\n   439→\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n   440→\tdefer mockServer.Close()\n   441→\n   442→\t// Initialize components\n   443→\tstorage, err := cache.NewFileStorage(cacheDir)\n   444→\tif err != nil {\n   445→\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n   446→\t}\n   447→\n   448→\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n   449→\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n   450→\n   451→\t// Create test server\n   452→\tmux := http.NewServeMux()\n   453→\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n   454→\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n   455→\t\tif err != nil {\n   456→\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n   457→\t\t\treturn\n   458→\t\t}\n   459→\n   460→\t\trewrittenContent := rw.RewriteM3U(content)\n   461→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   462→\t\tw.WriteHeader(http.StatusOK)\n   463→\t\tw.Write(rewrittenContent)\n   464→\t})\n   465→\n   466→\ttestServer := httptest.NewServer(mux)\n   467→\tdefer testServer.Close()\n   468→\n   469→\t// Make request\n   470→\tresp, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n   471→\tif err != nil {\n   472→\t\tt.Fatalf(\"Failed to make request: %v\", err)\n   473→\t}\n   474→\tdefer resp.Body.Close()\n   475→\n   476→\t// Read response body\n   477→\tbody := make([]byte, 4096)\n   478→\tn, _ := resp.Body.Read(body)\n   479→\tbodyStr := string(body[:n])\n   480→\n   481→\t// Verify all acestream URLs are rewritten correctly\n   482→\texpectedRewrites := []struct {\n   483→\t\toriginal  string\n   484→\t\trewritten string\n   485→\t}{\n   486→\t\t{\n   487→\t\t\toriginal:  \"acestream://0000111122223333444455556666777788889999\",\n   488→\t\t\trewritten: \"http://127.0.0.1:6878/ace/getstream?id=0000111122223333444455556666777788889999\",\n   489→\t\t},\n   490→\t\t{\n   491→\t\t\toriginal:  \"acestream://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n   492→\t\t\trewritten: \"http://127.0.0.1:6878/ace/getstream?id=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n   493→\t\t},\n   494→\t}\n   495→\n   496→\tfor _, test := range expectedRewrites {\n   497→\t\tif strings.Contains(bodyStr, test.original) {\n   498→\t\t\tt.Errorf(\"Expected original URL '%s' to be rewritten\", test.original)\n   499→\t\t}\n   500→\t\tif !strings.Contains(bodyStr, test.rewritten) {\n   501→\t\t\tt.Errorf(\"Expected rewritten URL '%s' to be present\", test.rewritten)\n   502→\t\t}\n   503→\t}\n   504→\n   505→\t// Verify HTTP URLs are preserved\n   506→\tif !strings.Contains(bodyStr, \"http://example.com/stream.m3u8\") {\n   507→\t\tt.Error(\"Expected HTTP URL to be preserved unchanged\")\n   508→\t}\n   509→\n   510→\t// Verify metadata is preserved (except logos which should be removed)\n   511→\tmetadataChecks := []string{\n   512→\t\t\"#EXTM3U\",\n   513→\t\t\"#EXTINF:-1 tvg-id=\\\"test1\\\"\",\n   514→\t\t\"tvg-name=\\\"Test Channel 1\\\"\",\n   515→\t\t\"group-title=\\\"Sports\\\"\",\n   516→\t\t\"Test Channel 1\",\n   517→\t}\n   518→\n   519→\tfor _, check := range metadataChecks {\n   520→\t\tif !strings.Contains(bodyStr, check) {\n   521→\t\t\tt.Errorf(\"Expected metadata '%s' to be preserved\", check)\n   522→\t\t}\n   523→\t}\n   524→\n   525→\t// Verify logos are removed\n   526→\tif strings.Contains(bodyStr, \"tvg-logo=\") {\n   527→\t\tt.Error(\"Expected tvg-logo metadata to be removed\")\n   528→\t}\n   529→}\n   530→\n   531→// TestIntegration_ContentTypeHeaders tests that Content-Type headers are correct\n   532→func TestIntegration_ContentTypeHeaders(t *testing.T) {\n   533→\t// Setup test environment\n   534→\tcacheDir, cleanup := setupTestEnvironment(t)\n   535→\tdefer cleanup()\n   536→\n   537→\t// Create mock IPFS server\n   538→\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n   539→\tdefer mockServer.Close()\n   540→\n   541→\t// Initialize components\n   542→\tstorage, err := cache.NewFileStorage(cacheDir)\n   543→\tif err != nil {\n   544→\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n   545→\t}\n   546→\n   547→\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n   548→\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n   549→\n   550→\t// Create test server\n   551→\tmux := http.NewServeMux()\n   552→\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n   553→\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n   554→\t\tif err != nil {\n   555→\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n   556→\t\t\treturn\n   557→\t\t}\n   558→\n   559→\t\trewrittenContent := rw.RewriteM3U(content)\n   560→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   561→\t\tw.WriteHeader(http.StatusOK)\n   562→\t\tw.Write(rewrittenContent)\n   563→\t})\n   564→\n   565→\ttestServer := httptest.NewServer(mux)\n   566→\tdefer testServer.Close()\n   567→\n   568→\t// Make request\n   569→\tresp, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n   570→\tif err != nil {\n   571→\t\tt.Fatalf(\"Failed to make request: %v\", err)\n   572→\t}\n   573→\tdefer resp.Body.Close()\n   574→\n   575→\t// Verify Content-Type header\n   576→\tcontentType := resp.Header.Get(\"Content-Type\")\n   577→\texpectedContentType := \"audio/x-mpegurl\"\n   578→\n   579→\tif contentType != expectedContentType {\n   580→\t\tt.Errorf(\"Expected Content-Type '%s', got '%s'\", expectedContentType, contentType)\n   581→\t}\n   582→\n   583→\t// Verify Content-Type is present and not empty\n   584→\tif contentType == \"\" {\n   585→\t\tt.Error(\"Content-Type header is missing\")\n   586→\t}\n   587→}\n   588→\n   589→// TestIntegration_HTTPStatusCodes tests HTTP status codes for all scenarios\n   590→func TestIntegration_HTTPStatusCodes(t *testing.T) {\n   591→\ttests := []struct {\n   592→\t\tname               string\n   593→\t\tipfsFails          bool\n   594→\t\tcacheExists        bool\n   595→\t\texpectedStatusCode int\n   596→\t\tdescription        string\n   597→\t}{\n   598→\t\t{\n   599→\t\t\tname:               \"Success - Fresh fetch\",\n   600→\t\t\tipfsFails:          false,\n   601→\t\t\tcacheExists:        false,\n   602→\t\t\texpectedStatusCode: http.StatusOK,\n   603→\t\t\tdescription:        \"Should return 200 OK when IPFS fetch succeeds\",\n   604→\t\t},\n   605→\t\t{\n   606→\t\t\tname:               \"Success - Cache hit\",\n   607→\t\t\tipfsFails:          false,\n   608→\t\t\tcacheExists:        true,\n   609→\t\t\texpectedStatusCode: http.StatusOK,\n   610→\t\t\tdescription:        \"Should return 200 OK when serving from cache\",\n   611→\t\t},\n   612→\t\t{\n   613→\t\t\tname:               \"Success - Stale cache fallback\",\n   614→\t\t\tipfsFails:          true,\n   615→\t\t\tcacheExists:        true,\n   616→\t\t\texpectedStatusCode: http.StatusOK,\n   617→\t\t\tdescription:        \"Should return 200 OK when serving stale cache\",\n   618→\t\t},\n   619→\t\t{\n   620→\t\t\tname:               \"Error - IPFS failure with no cache\",\n   621→\t\t\tipfsFails:          true,\n   622→\t\t\tcacheExists:        false,\n   623→\t\t\texpectedStatusCode: http.StatusBadGateway,\n   624→\t\t\tdescription:        \"Should return 502 Bad Gateway when IPFS fails and no cache exists\",\n   625→\t\t},\n   626→\t}\n   627→\n   628→\tfor _, tt := range tests {\n   629→\t\tt.Run(tt.name, func(t *testing.T) {\n   630→\t\t\t// Setup test environment\n   631→\t\t\tcacheDir, cleanup := setupTestEnvironment(t)\n   632→\t\t\tdefer cleanup()\n   633→\n   634→\t\t\t// Create mock IPFS server\n   635→\t\t\tmockServer := createMockIPFSServer(t, tt.ipfsFails, mockM3UContent)\n   636→\t\t\tdefer mockServer.Close()\n   637→\n   638→\t\t\t// Initialize components\n   639→\t\t\tstorage, err := cache.NewFileStorage(cacheDir)\n   640→\t\t\tif err != nil {\n   641→\t\t\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n   642→\t\t\t}\n   643→\n   644→\t\t\t// Pre-populate cache if needed\n   645→\t\t\tif tt.cacheExists {\n   646→\t\t\t\tcacheKey := fmt.Sprintf(\"%s\", mockServer.URL)\n   647→\t\t\t\tstorage.Set(cacheKey, []byte(mockM3UContent))\n   648→\t\t\t}\n   649→\n   650→\t\t\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n   651→\t\t\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n   652→\n   653→\t\t\t// Create test server\n   654→\t\t\tmux := http.NewServeMux()\n   655→\t\t\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n   656→\t\t\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n   657→\t\t\t\tif err != nil {\n   658→\t\t\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n   659→\t\t\t\t\treturn\n   660→\t\t\t\t}\n   661→\n   662→\t\t\t\trewrittenContent := rw.RewriteM3U(content)\n   663→\t\t\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   664→\t\t\t\tw.WriteHeader(http.StatusOK)\n   665→\t\t\t\tw.Write(rewrittenContent)\n   666→\t\t\t})\n   667→\n   668→\t\t\ttestServer := httptest.NewServer(mux)\n   669→\t\t\tdefer testServer.Close()\n   670→\n   671→\t\t\t// Make request\n   672→\t\t\tresp, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n   673→\t\t\tif err != nil {\n   674→\t\t\t\tt.Fatalf(\"Failed to make request: %v\", err)\n   675→\t\t\t}\n   676→\t\t\tdefer resp.Body.Close()\n   677→\n   678→\t\t\t// Verify status code\n   679→\t\t\tif resp.StatusCode != tt.expectedStatusCode {\n   680→\t\t\t\tt.Errorf(\"%s: Expected status code %d, got %d\", tt.description, tt.expectedStatusCode, resp.StatusCode)\n   681→\t\t\t}\n   682→\t\t})\n   683→\t}\n   684→}\n   685→\n   686→// TestIntegration_MethodNotAllowed tests that non-GET methods return 405\n   687→func TestIntegration_MethodNotAllowed(t *testing.T) {\n   688→\t// Setup test environment\n   689→\tcacheDir, cleanup := setupTestEnvironment(t)\n   690→\tdefer cleanup()\n   691→\n   692→\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n   693→\tdefer mockServer.Close()\n   694→\n   695→\tstorage, err := cache.NewFileStorage(cacheDir)\n   696→\tif err != nil {\n   697→\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n   698→\t}\n   699→\n   700→\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n   701→\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n   702→\n   703→\tmux := http.NewServeMux()\n   704→\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n   705→\t\tif r.Method != http.MethodGet {\n   706→\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n   707→\t\t\treturn\n   708→\t\t}\n   709→\n   710→\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n   711→\t\tif err != nil {\n   712→\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n   713→\t\t\treturn\n   714→\t\t}\n   715→\n   716→\t\trewrittenContent := rw.RewriteM3U(content)\n   717→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   718→\t\tw.WriteHeader(http.StatusOK)\n   719→\t\tw.Write(rewrittenContent)\n   720→\t})\n   721→\n   722→\ttestServer := httptest.NewServer(mux)\n   723→\tdefer testServer.Close()\n   724→\n   725→\t// Test POST method\n   726→\tresp, err := http.Post(testServer.URL+\"/playlists/test.m3u\", \"text/plain\", strings.NewReader(\"test\"))\n   727→\tif err != nil {\n   728→\t\tt.Fatalf(\"Failed to make POST request: %v\", err)\n   729→\t}\n   730→\tdefer resp.Body.Close()\n   731→\n   732→\tif resp.StatusCode != http.StatusMethodNotAllowed {\n   733→\t\tt.Errorf(\"Expected status code %d for POST, got %d\", http.StatusMethodNotAllowed, resp.StatusCode)\n   734→\t}\n   735→}\n   736→\n   737→// TestIntegration_RealEndpoints tests the actual elcano and newera endpoints\n   738→func TestIntegration_RealEndpoints(t *testing.T) {\n   739→\t// Setup test environment\n   740→\tcacheDir := t.TempDir()\n   741→\n   742→\t// Set environment variables\n   743→\tos.Setenv(\"CACHE_DIR\", cacheDir)\n   744→\tos.Setenv(\"CACHE_TTL\", \"1h\")\n   745→\tos.Setenv(\"HTTP_ADDRESS\", \"127.0.0.1\")\n   746→\tos.Setenv(\"HTTP_PORT\", \"0\") // Use random port\n   747→\tos.Setenv(\"ACESTREAM_PLAYER_BASE_URL\", \"http://127.0.0.1:6878/ace/getstream\")\n   748→\n   749→\tdefer func() {\n   750→\t\tos.Unsetenv(\"CACHE_DIR\")\n   751→\t\tos.Unsetenv(\"CACHE_TTL\")\n   752→\t\tos.Unsetenv(\"HTTP_ADDRESS\")\n   753→\t\tos.Unsetenv(\"HTTP_PORT\")\n   754→\t\tos.Unsetenv(\"ACESTREAM_PLAYER_BASE_URL\")\n   755→\t}()\n   756→\n   757→\t// Load configuration\n   758→\tcfg, err := loadConfig()\n   759→\tif err != nil {\n   760→\t\tt.Fatalf(\"Failed to load config: %v\", err)\n   761→\t}\n   762→\n   763→\t// Ensure cache directory is valid\n   764→\tif !filepath.IsAbs(cfg.CacheDir) {\n   765→\t\tt.Fatalf(\"Cache directory must be absolute path, got: %s\", cfg.CacheDir)\n   766→\t}\n   767→\n   768→\t// Initialize components\n   769→\tstorage, err := cache.NewFileStorage(cfg.CacheDir)\n   770→\tif err != nil {\n   771→\t\tt.Fatalf(\"Failed to initialize storage: %v\", err)\n   772→\t}\n   773→\n   774→\tfetch := fetcher.New(30*time.Second, storage, cfg.CacheTTL)\n   775→\trw := rewriter.New(cfg.AcestreamPlayerBaseURL)\n   776→\n   777→\t// Create mock IPFS server\n   778→\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n   779→\tdefer mockServer.Close()\n   780→\n   781→\t// Create test server with real endpoint handlers\n   782→\tmux := http.NewServeMux()\n   783→\n   784→\t// Health endpoint\n   785→\tmux.HandleFunc(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n   786→\t\tw.WriteHeader(http.StatusOK)\n   787→\t\tw.Write([]byte(\"OK\"))\n   788→\t})\n   789→\n   790→\t// Elcano endpoint (modified to use mock server)\n   791→\tmux.HandleFunc(\"/playlists/elcano.m3u\", func(w http.ResponseWriter, r *http.Request) {\n   792→\t\tif r.Method != http.MethodGet {\n   793→\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n   794→\t\t\treturn\n   795→\t\t}\n   796→\n   797→\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n   798→\t\tif err != nil {\n   799→\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n   800→\t\t\treturn\n   801→\t\t}\n   802→\n   803→\t\trewrittenContent := rw.RewriteM3U(content)\n   804→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   805→\t\tw.WriteHeader(http.StatusOK)\n   806→\t\tw.Write(rewrittenContent)\n   807→\t})\n   808→\n   809→\t// NewEra endpoint (modified to use mock server)\n   810→\tmux.HandleFunc(\"/playlists/newera.m3u\", func(w http.ResponseWriter, r *http.Request) {\n   811→\t\tif r.Method != http.MethodGet {\n   812→\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n   813→\t\t\treturn\n   814→\t\t}\n   815→\n   816→\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n   817→\t\tif err != nil {\n   818→\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n   819→\t\t\treturn\n   820→\t\t}\n   821→\n   822→\t\trewrittenContent := rw.RewriteM3U(content)\n   823→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   824→\t\tw.WriteHeader(http.StatusOK)\n   825→\t\tw.Write(rewrittenContent)\n   826→\t})\n   827→\n   828→\ttestServer := httptest.NewServer(mux)\n   829→\tdefer testServer.Close()\n   830→\n   831→\t// Test health endpoint\n   832→\tt.Run(\"Health endpoint\", func(t *testing.T) {\n   833→\t\tresp, err := http.Get(testServer.URL + \"/health\")\n   834→\t\tif err != nil {\n   835→\t\t\tt.Fatalf(\"Failed to request health endpoint: %v\", err)\n   836→\t\t}\n   837→\t\tdefer resp.Body.Close()\n   838→\n   839→\t\tif resp.StatusCode != http.StatusOK {\n   840→\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n   841→\t\t}\n   842→\n   843→\t\tbody := make([]byte, 10)\n   844→\t\tn, _ := resp.Body.Read(body)\n   845→\t\tif string(body[:n]) != \"OK\" {\n   846→\t\t\tt.Errorf(\"Expected body 'OK', got '%s'\", string(body[:n]))\n   847→\t\t}\n   848→\t})\n   849→\n   850→\t// Test elcano endpoint\n   851→\tt.Run(\"Elcano endpoint\", func(t *testing.T) {\n   852→\t\tresp, err := http.Get(testServer.URL + \"/playlists/elcano.m3u\")\n   853→\t\tif err != nil {\n   854→\t\t\tt.Fatalf(\"Failed to request elcano endpoint: %v\", err)\n   855→\t\t}\n   856→\t\tdefer resp.Body.Close()\n   857→\n   858→\t\tif resp.StatusCode != http.StatusOK {\n   859→\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n   860→\t\t}\n   861→\n   862→\t\tcontentType := resp.Header.Get(\"Content-Type\")\n   863→\t\tif contentType != \"audio/x-mpegurl\" {\n   864→\t\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n   865→\t\t}\n   866→\n   867→\t\tbody := make([]byte, 4096)\n   868→\t\tn, _ := resp.Body.Read(body)\n   869→\t\tbodyStr := string(body[:n])\n   870→\n   871→\t\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=\") {\n   872→\t\t\tt.Error(\"Expected rewritten acestream URLs\")\n   873→\t\t}\n   874→\t})\n   875→\n   876→\t// Test newera endpoint\n   877→\tt.Run(\"NewEra endpoint\", func(t *testing.T) {\n   878→\t\tresp, err := http.Get(testServer.URL + \"/playlists/newera.m3u\")\n   879→\t\tif err != nil {\n   880→\t\t\tt.Fatalf(\"Failed to request newera endpoint: %v\", err)\n   881→\t\t}\n   882→\t\tdefer resp.Body.Close()\n   883→\n   884→\t\tif resp.StatusCode != http.StatusOK {\n   885→\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n   886→\t\t}\n   887→\n   888→\t\tcontentType := resp.Header.Get(\"Content-Type\")\n   889→\t\tif contentType != \"audio/x-mpegurl\" {\n   890→\t\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n   891→\t\t}\n   892→\n   893→\t\tbody := make([]byte, 4096)\n   894→\t\tn, _ := resp.Body.Read(body)\n   895→\t\tbodyStr := string(body[:n])\n   896→\n   897→\t\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=\") {\n   898→\t\t\tt.Error(\"Expected rewritten acestream URLs\")\n   899→\t\t}\n   900→\t})\n   901→}\n   902→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"881b735c-95a9-4933-849d-0d92c870509b","tool_use_result":{"type":"text","file":{"filePath":"/home/alorle/gh/alorle/iptv-manager/main_test.go","content":"package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alorle/iptv-manager/cache\"\n\t\"github.com/alorle/iptv-manager/fetcher\"\n\t\"github.com/alorle/iptv-manager/rewriter\"\n)\n\nconst (\n\tmockM3UContent = `#EXTM3U\n#EXTINF:-1 tvg-id=\"test1\" tvg-name=\"Test Channel 1\" tvg-logo=\"http://example.com/logo1.png\" group-title=\"Sports\",Test Channel 1\nacestream://0000111122223333444455556666777788889999\n#EXTINF:-1 tvg-id=\"test2\" tvg-name=\"Test Channel 2\" group-title=\"Movies\",Test Channel 2\nhttp://example.com/stream.m3u8\n#EXTINF:-1 tvg-id=\"test3\" tvg-name=\"Test Channel 3\",Test Channel 3\nacestream://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n`\n)\n\n// setupTestEnvironment creates a temporary directory and returns cleanup function\nfunc setupTestEnvironment(t *testing.T) (string, func()) {\n\tt.Helper()\n\ttempDir := t.TempDir()\n\treturn tempDir, func() {}\n}\n\n// createMockIPFSServer creates an HTTP server that simulates IPFS behavior\nfunc createMockIPFSServer(t *testing.T, shouldFail bool, content string) *httptest.Server {\n\tt.Helper()\n\treturn httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif shouldFail {\n\t\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\t\tw.Write([]byte(\"IPFS node unavailable\"))\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(content))\n\t}))\n}\n\n// TestIntegration_FreshFetchFromMockIPFS tests fetching fresh content from mock IPFS server\nfunc TestIntegration_FreshFetchFromMockIPFS(t *testing.T) {\n\t// Setup test environment\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\t// Create mock IPFS server\n\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n\tdefer mockServer.Close()\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t// Create test server\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, fromCache, stale, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\tif fromCache {\n\t\t\tt.Error(\"Expected fresh fetch, but got cached content\")\n\t\t}\n\t\tif stale {\n\t\t\tt.Error(\"Expected fresh content, but got stale cache\")\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Make request\n\tresp, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\t// Verify HTTP status code\n\tif resp.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t}\n\n\t// Verify Content-Type header\n\tcontentType := resp.Header.Get(\"Content-Type\")\n\tif contentType != \"audio/x-mpegurl\" {\n\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t}\n\n\t// Read and verify response body\n\tbody := make([]byte, 4096)\n\tn, _ := resp.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify URL rewriting occurred\n\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=0000111122223333444455556666777788889999\") {\n\t\tt.Error(\"Expected first acestream URL to be rewritten\")\n\t}\n\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") {\n\t\tt.Error(\"Expected second acestream URL to be rewritten\")\n\t}\n\tif !strings.Contains(bodyStr, \"http://example.com/stream.m3u8\") {\n\t\tt.Error(\"Expected HTTP URL to be preserved\")\n\t}\n\tif !strings.Contains(bodyStr, \"#EXTINF\") {\n\t\tt.Error(\"Expected metadata to be preserved\")\n\t}\n}\n\n// TestIntegration_CacheHit tests serving content from fresh cache\nfunc TestIntegration_CacheHit(t *testing.T) {\n\t// Setup test environment\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\trequestCount := 0\n\t// Create mock IPFS server that counts requests\n\tmockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\trequestCount++\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(mockM3UContent))\n\t}))\n\tdefer mockServer.Close()\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t// Create test server\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, fromCache, stale, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\n\t\t// Store cache status for verification\n\t\tw.Header().Set(\"X-From-Cache\", fmt.Sprintf(\"%v\", fromCache))\n\t\tw.Header().Set(\"X-Stale\", fmt.Sprintf(\"%v\", stale))\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// First request - should fetch from IPFS\n\tresp1, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make first request: %v\", err)\n\t}\n\tresp1.Body.Close()\n\n\tif requestCount != 1 {\n\t\tt.Errorf(\"Expected 1 IPFS request after first fetch, got %d\", requestCount)\n\t}\n\n\t// Second request - should serve from cache\n\tresp2, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make second request: %v\", err)\n\t}\n\tdefer resp2.Body.Close()\n\n\t// Verify no additional IPFS requests were made\n\tif requestCount != 1 {\n\t\tt.Errorf(\"Expected 1 IPFS request after cache hit, got %d\", requestCount)\n\t}\n\n\t// Verify HTTP status code\n\tif resp2.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp2.StatusCode)\n\t}\n\n\t// Verify Content-Type header\n\tcontentType := resp2.Header.Get(\"Content-Type\")\n\tif contentType != \"audio/x-mpegurl\" {\n\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t}\n\n\t// Read response body\n\tbody := make([]byte, 4096)\n\tn, _ := resp2.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify URL rewriting still works\n\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=0000111122223333444455556666777788889999\") {\n\t\tt.Error(\"Expected acestream URL to be rewritten from cache\")\n\t}\n}\n\n// TestIntegration_ExpiredCacheRefresh tests cache refresh when TTL expires\nfunc TestIntegration_ExpiredCacheRefresh(t *testing.T) {\n\t// Setup test environment\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\trequestCount := 0\n\t// Create mock IPFS server\n\tmockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\trequestCount++\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\t// Send different content on second request\n\t\tif requestCount == 1 {\n\t\t\tw.Write([]byte(mockM3UContent))\n\t\t} else {\n\t\t\tw.Write([]byte(\"#EXTM3U\\n#EXTINF:-1,Updated Channel\\nacestream://bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"))\n\t\t}\n\t}))\n\tdefer mockServer.Close()\n\n\t// Initialize components with very short TTL\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 100*time.Millisecond) // 100ms TTL\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t// Create test server\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// First request - should fetch from IPFS\n\tresp1, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make first request: %v\", err)\n\t}\n\tbody1 := make([]byte, 4096)\n\tn1, _ := resp1.Body.Read(body1)\n\tresp1.Body.Close()\n\n\tif requestCount != 1 {\n\t\tt.Errorf(\"Expected 1 IPFS request, got %d\", requestCount)\n\t}\n\n\t// Wait for cache to expire\n\ttime.Sleep(150 * time.Millisecond)\n\n\t// Second request - should refresh cache\n\tresp2, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make second request: %v\", err)\n\t}\n\tbody2 := make([]byte, 4096)\n\tn2, _ := resp2.Body.Read(body2)\n\tresp2.Body.Close()\n\n\tif requestCount != 2 {\n\t\tt.Errorf(\"Expected 2 IPFS requests after cache expiration, got %d\", requestCount)\n\t}\n\n\t// Verify HTTP status code\n\tif resp2.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp2.StatusCode)\n\t}\n\n\t// Verify Content-Type header\n\tcontentType := resp2.Header.Get(\"Content-Type\")\n\tif contentType != \"audio/x-mpegurl\" {\n\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t}\n\n\t// Verify content changed (cache was refreshed)\n\tbodyStr1 := string(body1[:n1])\n\tbodyStr2 := string(body2[:n2])\n\n\tif !strings.Contains(bodyStr2, \"Updated Channel\") {\n\t\tt.Error(\"Expected refreshed content with 'Updated Channel'\")\n\t}\n\tif !strings.Contains(bodyStr2, \"http://127.0.0.1:6878/ace/getstream?id=bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\") {\n\t\tt.Error(\"Expected refreshed content with rewritten URL\")\n\t}\n\tif bodyStr1 == bodyStr2 {\n\t\tt.Error(\"Expected different content after cache refresh\")\n\t}\n}\n\n// TestIntegration_IPFSFailureWithStaleCacheFallback tests serving stale cache when IPFS fails\nfunc TestIntegration_IPFSFailureWithStaleCacheFallback(t *testing.T) {\n\t// Setup test environment\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\tipfsAvailable := true\n\t// Create mock IPFS server that can be toggled\n\tmockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif !ipfsAvailable {\n\t\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\t\tw.Write([]byte(\"IPFS node unavailable\"))\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(mockM3UContent))\n\t}))\n\tdefer mockServer.Close()\n\n\t// Initialize components with short TTL\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 100*time.Millisecond)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t// Create test server\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcontent, fromCache, stale, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.Header().Set(\"X-From-Cache\", fmt.Sprintf(\"%v\", fromCache))\n\t\tw.Header().Set(\"X-Stale\", fmt.Sprintf(\"%v\", stale))\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// First request - populate cache\n\tresp1, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make first request: %v\", err)\n\t}\n\tresp1.Body.Close()\n\n\t// Wait for cache to expire\n\ttime.Sleep(150 * time.Millisecond)\n\n\t// Make IPFS unavailable\n\tipfsAvailable = false\n\n\t// Second request - should serve stale cache\n\tresp2, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make second request: %v\", err)\n\t}\n\tdefer resp2.Body.Close()\n\n\t// Verify HTTP status code (should still be OK)\n\tif resp2.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp2.StatusCode)\n\t}\n\n\t// Verify Content-Type header\n\tcontentType := resp2.Header.Get(\"Content-Type\")\n\tif contentType != \"audio/x-mpegurl\" {\n\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t}\n\n\t// Read response body\n\tbody := make([]byte, 4096)\n\tn, _ := resp2.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify we got stale cache content (original content should be present)\n\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=0000111122223333444455556666777788889999\") {\n\t\tt.Error(\"Expected stale cache content with rewritten URL\")\n\t}\n\tif !strings.Contains(bodyStr, \"Test Channel 1\") {\n\t\tt.Error(\"Expected stale cache content with original metadata\")\n\t}\n}\n\n// TestIntegration_URLRewritingOutput tests that URL rewriting produces correct output\nfunc TestIntegration_URLRewritingOutput(t *testing.T) {\n\t// Setup test environment\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\t// Create mock IPFS server\n\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n\tdefer mockServer.Close()\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t// Create test server\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Make request\n\tresp, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read response body\n\tbody := make([]byte, 4096)\n\tn, _ := resp.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify all acestream URLs are rewritten correctly\n\texpectedRewrites := []struct {\n\t\toriginal  string\n\t\trewritten string\n\t}{\n\t\t{\n\t\t\toriginal:  \"acestream://0000111122223333444455556666777788889999\",\n\t\t\trewritten: \"http://127.0.0.1:6878/ace/getstream?id=0000111122223333444455556666777788889999\",\n\t\t},\n\t\t{\n\t\t\toriginal:  \"acestream://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t\t\trewritten: \"http://127.0.0.1:6878/ace/getstream?id=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t\t},\n\t}\n\n\tfor _, test := range expectedRewrites {\n\t\tif strings.Contains(bodyStr, test.original) {\n\t\t\tt.Errorf(\"Expected original URL '%s' to be rewritten\", test.original)\n\t\t}\n\t\tif !strings.Contains(bodyStr, test.rewritten) {\n\t\t\tt.Errorf(\"Expected rewritten URL '%s' to be present\", test.rewritten)\n\t\t}\n\t}\n\n\t// Verify HTTP URLs are preserved\n\tif !strings.Contains(bodyStr, \"http://example.com/stream.m3u8\") {\n\t\tt.Error(\"Expected HTTP URL to be preserved unchanged\")\n\t}\n\n\t// Verify metadata is preserved (except logos which should be removed)\n\tmetadataChecks := []string{\n\t\t\"#EXTM3U\",\n\t\t\"#EXTINF:-1 tvg-id=\\\"test1\\\"\",\n\t\t\"tvg-name=\\\"Test Channel 1\\\"\",\n\t\t\"group-title=\\\"Sports\\\"\",\n\t\t\"Test Channel 1\",\n\t}\n\n\tfor _, check := range metadataChecks {\n\t\tif !strings.Contains(bodyStr, check) {\n\t\t\tt.Errorf(\"Expected metadata '%s' to be preserved\", check)\n\t\t}\n\t}\n\n\t// Verify logos are removed\n\tif strings.Contains(bodyStr, \"tvg-logo=\") {\n\t\tt.Error(\"Expected tvg-logo metadata to be removed\")\n\t}\n}\n\n// TestIntegration_ContentTypeHeaders tests that Content-Type headers are correct\nfunc TestIntegration_ContentTypeHeaders(t *testing.T) {\n\t// Setup test environment\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\t// Create mock IPFS server\n\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n\tdefer mockServer.Close()\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t// Create test server\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Make request\n\tresp, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\t// Verify Content-Type header\n\tcontentType := resp.Header.Get(\"Content-Type\")\n\texpectedContentType := \"audio/x-mpegurl\"\n\n\tif contentType != expectedContentType {\n\t\tt.Errorf(\"Expected Content-Type '%s', got '%s'\", expectedContentType, contentType)\n\t}\n\n\t// Verify Content-Type is present and not empty\n\tif contentType == \"\" {\n\t\tt.Error(\"Content-Type header is missing\")\n\t}\n}\n\n// TestIntegration_HTTPStatusCodes tests HTTP status codes for all scenarios\nfunc TestIntegration_HTTPStatusCodes(t *testing.T) {\n\ttests := []struct {\n\t\tname               string\n\t\tipfsFails          bool\n\t\tcacheExists        bool\n\t\texpectedStatusCode int\n\t\tdescription        string\n\t}{\n\t\t{\n\t\t\tname:               \"Success - Fresh fetch\",\n\t\t\tipfsFails:          false,\n\t\t\tcacheExists:        false,\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\tdescription:        \"Should return 200 OK when IPFS fetch succeeds\",\n\t\t},\n\t\t{\n\t\t\tname:               \"Success - Cache hit\",\n\t\t\tipfsFails:          false,\n\t\t\tcacheExists:        true,\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\tdescription:        \"Should return 200 OK when serving from cache\",\n\t\t},\n\t\t{\n\t\t\tname:               \"Success - Stale cache fallback\",\n\t\t\tipfsFails:          true,\n\t\t\tcacheExists:        true,\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\tdescription:        \"Should return 200 OK when serving stale cache\",\n\t\t},\n\t\t{\n\t\t\tname:               \"Error - IPFS failure with no cache\",\n\t\t\tipfsFails:          true,\n\t\t\tcacheExists:        false,\n\t\t\texpectedStatusCode: http.StatusBadGateway,\n\t\t\tdescription:        \"Should return 502 Bad Gateway when IPFS fails and no cache exists\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Setup test environment\n\t\t\tcacheDir, cleanup := setupTestEnvironment(t)\n\t\t\tdefer cleanup()\n\n\t\t\t// Create mock IPFS server\n\t\t\tmockServer := createMockIPFSServer(t, tt.ipfsFails, mockM3UContent)\n\t\t\tdefer mockServer.Close()\n\n\t\t\t// Initialize components\n\t\t\tstorage, err := cache.NewFileStorage(cacheDir)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t\t\t}\n\n\t\t\t// Pre-populate cache if needed\n\t\t\tif tt.cacheExists {\n\t\t\t\tcacheKey := fmt.Sprintf(\"%s\", mockServer.URL)\n\t\t\t\tstorage.Set(cacheKey, []byte(mockM3UContent))\n\t\t\t}\n\n\t\t\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\t\t\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t\t\t// Create test server\n\t\t\tmux := http.NewServeMux()\n\t\t\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\t\t\tif err != nil {\n\t\t\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\trewrittenContent := rw.RewriteM3U(content)\n\t\t\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\t\tw.Write(rewrittenContent)\n\t\t\t})\n\n\t\t\ttestServer := httptest.NewServer(mux)\n\t\t\tdefer testServer.Close()\n\n\t\t\t// Make request\n\t\t\tresp, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\n\t\t\t// Verify status code\n\t\t\tif resp.StatusCode != tt.expectedStatusCode {\n\t\t\t\tt.Errorf(\"%s: Expected status code %d, got %d\", tt.description, tt.expectedStatusCode, resp.StatusCode)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestIntegration_MethodNotAllowed tests that non-GET methods return 405\nfunc TestIntegration_MethodNotAllowed(t *testing.T) {\n\t// Setup test environment\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n\tdefer mockServer.Close()\n\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Test POST method\n\tresp, err := http.Post(testServer.URL+\"/playlists/test.m3u\", \"text/plain\", strings.NewReader(\"test\"))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make POST request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusMethodNotAllowed {\n\t\tt.Errorf(\"Expected status code %d for POST, got %d\", http.StatusMethodNotAllowed, resp.StatusCode)\n\t}\n}\n\n// TestIntegration_RealEndpoints tests the actual elcano and newera endpoints\nfunc TestIntegration_RealEndpoints(t *testing.T) {\n\t// Setup test environment\n\tcacheDir := t.TempDir()\n\n\t// Set environment variables\n\tos.Setenv(\"CACHE_DIR\", cacheDir)\n\tos.Setenv(\"CACHE_TTL\", \"1h\")\n\tos.Setenv(\"HTTP_ADDRESS\", \"127.0.0.1\")\n\tos.Setenv(\"HTTP_PORT\", \"0\") // Use random port\n\tos.Setenv(\"ACESTREAM_PLAYER_BASE_URL\", \"http://127.0.0.1:6878/ace/getstream\")\n\n\tdefer func() {\n\t\tos.Unsetenv(\"CACHE_DIR\")\n\t\tos.Unsetenv(\"CACHE_TTL\")\n\t\tos.Unsetenv(\"HTTP_ADDRESS\")\n\t\tos.Unsetenv(\"HTTP_PORT\")\n\t\tos.Unsetenv(\"ACESTREAM_PLAYER_BASE_URL\")\n\t}()\n\n\t// Load configuration\n\tcfg, err := loadConfig()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to load config: %v\", err)\n\t}\n\n\t// Ensure cache directory is valid\n\tif !filepath.IsAbs(cfg.CacheDir) {\n\t\tt.Fatalf(\"Cache directory must be absolute path, got: %s\", cfg.CacheDir)\n\t}\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cfg.CacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to initialize storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(30*time.Second, storage, cfg.CacheTTL)\n\trw := rewriter.New(cfg.AcestreamPlayerBaseURL)\n\n\t// Create mock IPFS server\n\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n\tdefer mockServer.Close()\n\n\t// Create test server with real endpoint handlers\n\tmux := http.NewServeMux()\n\n\t// Health endpoint\n\tmux.HandleFunc(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\t// Elcano endpoint (modified to use mock server)\n\tmux.HandleFunc(\"/playlists/elcano.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\t// NewEra endpoint (modified to use mock server)\n\tmux.HandleFunc(\"/playlists/newera.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Test health endpoint\n\tt.Run(\"Health endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/health\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request health endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tbody := make([]byte, 10)\n\t\tn, _ := resp.Body.Read(body)\n\t\tif string(body[:n]) != \"OK\" {\n\t\t\tt.Errorf(\"Expected body 'OK', got '%s'\", string(body[:n]))\n\t\t}\n\t})\n\n\t// Test elcano endpoint\n\tt.Run(\"Elcano endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/playlists/elcano.m3u\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request elcano endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tcontentType := resp.Header.Get(\"Content-Type\")\n\t\tif contentType != \"audio/x-mpegurl\" {\n\t\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t\t}\n\n\t\tbody := make([]byte, 4096)\n\t\tn, _ := resp.Body.Read(body)\n\t\tbodyStr := string(body[:n])\n\n\t\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=\") {\n\t\t\tt.Error(\"Expected rewritten acestream URLs\")\n\t\t}\n\t})\n\n\t// Test newera endpoint\n\tt.Run(\"NewEra endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/playlists/newera.m3u\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request newera endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tcontentType := resp.Header.Get(\"Content-Type\")\n\t\tif contentType != \"audio/x-mpegurl\" {\n\t\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t\t}\n\n\t\tbody := make([]byte, 4096)\n\t\tn, _ := resp.Body.Read(body)\n\t\tbodyStr := string(body[:n])\n\n\t\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=\") {\n\t\t\tt.Error(\"Expected rewritten acestream URLs\")\n\t\t}\n\t})\n}\n","numLines":902,"startLine":1,"totalLines":902}}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01L7MC7r6CtVKuXfdBMmxwDb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014FhjsGPruy3mE8EdcZxvYL","name":"TodoWrite","input":{"todos":[{"content":"Examine existing test patterns in main_test.go","activeForm":"Examining existing test patterns in main_test.go","status":"completed"},{"content":"Review the unified playlist endpoint implementation","activeForm":"Reviewing the unified playlist endpoint implementation","status":"in_progress"},{"content":"Write integration tests covering all acceptance criteria","activeForm":"Writing integration tests covering all acceptance criteria","status":"pending"},{"content":"Run go build ./... to verify build","activeForm":"Running go build ./... to verify build","status":"pending"},{"content":"Run go test ./... to verify all tests pass","activeForm":"Running go test ./... to verify all tests pass","status":"pending"},{"content":"Commit changes with feat message","activeForm":"Committing changes with feat message","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":12838,"cache_read_input_tokens":41295,"cache_creation":{"ephemeral_5m_input_tokens":12838,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"c0c9c0ab-1b86-4b91-937c-ab014d3c7532"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014FhjsGPruy3mE8EdcZxvYL","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"58314fbd-d9ac-45b7-8f91-09ba1e679a30","tool_use_result":{"oldTodos":[{"content":"Examine existing test patterns in main_test.go","status":"in_progress","activeForm":"Examining existing test patterns in main_test.go"},{"content":"Review the unified playlist endpoint implementation","status":"pending","activeForm":"Reviewing the unified playlist endpoint implementation"},{"content":"Write integration tests covering all acceptance criteria","status":"pending","activeForm":"Writing integration tests covering all acceptance criteria"},{"content":"Run go build ./... to verify build","status":"pending","activeForm":"Running go build ./... to verify build"},{"content":"Run go test ./... to verify all tests pass","status":"pending","activeForm":"Running go test ./... to verify all tests pass"},{"content":"Commit changes with feat message","status":"pending","activeForm":"Committing changes with feat message"}],"newTodos":[{"content":"Examine existing test patterns in main_test.go","status":"completed","activeForm":"Examining existing test patterns in main_test.go"},{"content":"Review the unified playlist endpoint implementation","status":"in_progress","activeForm":"Reviewing the unified playlist endpoint implementation"},{"content":"Write integration tests covering all acceptance criteria","status":"pending","activeForm":"Writing integration tests covering all acceptance criteria"},{"content":"Run go build ./... to verify build","status":"pending","activeForm":"Running go build ./... to verify build"},{"content":"Run go test ./... to verify all tests pass","status":"pending","activeForm":"Running go test ./... to verify all tests pass"},{"content":"Commit changes with feat message","status":"pending","activeForm":"Committing changes with feat message"}]}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01M7vr58VEUi2H6cretuwJtg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CWTzz6r2g8HPUj87XUTcUw","name":"Read","input":{"file_path":"/home/alorle/gh/alorle/iptv-manager/main.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":302,"cache_read_input_tokens":54133,"cache_creation":{"ephemeral_5m_input_tokens":302,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"1f05e60f-608d-4869-b5bc-12490c7c6bae"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CWTzz6r2g8HPUj87XUTcUw","type":"tool_result","content":"     1→package main\n     2→\n     3→import (\n     4→\t\"fmt\"\n     5→\t\"log\"\n     6→\t\"net/http\"\n     7→\t\"os\"\n     8→\t\"path/filepath\"\n     9→\t\"strings\"\n    10→\t\"time\"\n    11→\n    12→\t\"github.com/alorle/iptv-manager/cache\"\n    13→\t\"github.com/alorle/iptv-manager/fetcher\"\n    14→\t\"github.com/alorle/iptv-manager/rewriter\"\n    15→)\n    16→\n    17→type Config struct {\n    18→\tHTTPAddress            string\n    19→\tHTTPPort               string\n    20→\tAcestreamPlayerBaseURL string\n    21→\tCacheDir               string\n    22→\tCacheTTL               time.Duration\n    23→}\n    24→\n    25→func loadConfig() (*Config, error) {\n    26→\tcfg := &Config{\n    27→\t\tHTTPAddress:            os.Getenv(\"HTTP_ADDRESS\"),\n    28→\t\tHTTPPort:               os.Getenv(\"HTTP_PORT\"),\n    29→\t\tAcestreamPlayerBaseURL: os.Getenv(\"ACESTREAM_PLAYER_BASE_URL\"),\n    30→\t\tCacheDir:               os.Getenv(\"CACHE_DIR\"),\n    31→\t}\n    32→\n    33→\t// Set defaults\n    34→\tif cfg.HTTPAddress == \"\" {\n    35→\t\tcfg.HTTPAddress = \"127.0.0.1\"\n    36→\t}\n    37→\tif cfg.HTTPPort == \"\" {\n    38→\t\tcfg.HTTPPort = \"8080\"\n    39→\t}\n    40→\tif cfg.AcestreamPlayerBaseURL == \"\" {\n    41→\t\tcfg.AcestreamPlayerBaseURL = \"http://127.0.0.1:6878/ace/getstream\"\n    42→\t}\n    43→\n    44→\t// Validate and set CACHE_DIR\n    45→\tif cfg.CacheDir == \"\" {\n    46→\t\treturn nil, fmt.Errorf(\"CACHE_DIR environment variable is required\")\n    47→\t}\n    48→\t// Ensure cache directory is an absolute path\n    49→\tif !filepath.IsAbs(cfg.CacheDir) {\n    50→\t\tabsPath, err := filepath.Abs(cfg.CacheDir)\n    51→\t\tif err != nil {\n    52→\t\t\treturn nil, fmt.Errorf(\"failed to resolve absolute path for CACHE_DIR: %w\", err)\n    53→\t\t}\n    54→\t\tcfg.CacheDir = absPath\n    55→\t}\n    56→\n    57→\t// Parse CACHE_TTL\n    58→\tcacheTTLStr := os.Getenv(\"CACHE_TTL\")\n    59→\tif cacheTTLStr == \"\" {\n    60→\t\treturn nil, fmt.Errorf(\"CACHE_TTL environment variable is required\")\n    61→\t}\n    62→\tttl, err := time.ParseDuration(cacheTTLStr)\n    63→\tif err != nil {\n    64→\t\treturn nil, fmt.Errorf(\"invalid CACHE_TTL format (expected duration like '1h', '30m'): %w\", err)\n    65→\t}\n    66→\tif ttl <= 0 {\n    67→\t\treturn nil, fmt.Errorf(\"CACHE_TTL must be positive, got: %s\", cacheTTLStr)\n    68→\t}\n    69→\tcfg.CacheTTL = ttl\n    70→\n    71→\treturn cfg, nil\n    72→}\n    73→\n    74→func main() {\n    75→\t// Load and validate configuration\n    76→\tcfg, err := loadConfig()\n    77→\tif err != nil {\n    78→\t\tlog.Fatalf(\"Configuration error: %v\", err)\n    79→\t}\n    80→\n    81→\t// Print configuration\n    82→\tfmt.Printf(\"httpAddress: %v\\n\", cfg.HTTPAddress)\n    83→\tfmt.Printf(\"httpPort: %v\\n\", cfg.HTTPPort)\n    84→\tfmt.Printf(\"acestreamPlayerBaseUrl: %v\\n\", cfg.AcestreamPlayerBaseURL)\n    85→\tfmt.Printf(\"cacheDir: %v\\n\", cfg.CacheDir)\n    86→\tfmt.Printf(\"cacheTTL: %v\\n\", cfg.CacheTTL)\n    87→\n    88→\t// Initialize cache storage\n    89→\tstorage, err := cache.NewFileStorage(cfg.CacheDir)\n    90→\tif err != nil {\n    91→\t\tlog.Fatalf(\"Failed to initialize cache storage: %v\", err)\n    92→\t}\n    93→\n    94→\t// Initialize fetcher with 30 second timeout\n    95→\tfetch := fetcher.New(30*time.Second, storage, cfg.CacheTTL)\n    96→\n    97→\t// Initialize rewriter\n    98→\trw := rewriter.New(cfg.AcestreamPlayerBaseURL)\n    99→\n   100→\thandler := http.NewServeMux()\n   101→\n   102→\thandler.HandleFunc(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n   103→\t\tw.WriteHeader(http.StatusOK)\n   104→\t\tw.Write([]byte(\"OK\"))\n   105→\t})\n   106→\n   107→\t// Elcano playlist endpoint\n   108→\thandler.HandleFunc(\"/playlists/elcano.m3u\", func(w http.ResponseWriter, r *http.Request) {\n   109→\t\tif r.Method != http.MethodGet {\n   110→\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n   111→\t\t\treturn\n   112→\t\t}\n   113→\n   114→\t\tsourceURL := \"https://ipfs.io/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes_acestream.m3u\"\n   115→\n   116→\t\t// Fetch with cache fallback\n   117→\t\tcontent, fromCache, stale, err := fetch.FetchWithCache(sourceURL)\n   118→\t\tif err != nil {\n   119→\t\t\tlog.Printf(\"Failed to fetch elcano playlist: %v\", err)\n   120→\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n   121→\t\t\treturn\n   122→\t\t}\n   123→\n   124→\t\t// Log cache status\n   125→\t\tif fromCache {\n   126→\t\t\tif stale {\n   127→\t\t\t\tlog.Printf(\"Serving stale cache for elcano playlist\")\n   128→\t\t\t} else {\n   129→\t\t\t\tlog.Printf(\"Serving fresh cache for elcano playlist\")\n   130→\t\t\t}\n   131→\t\t} else {\n   132→\t\t\tlog.Printf(\"Serving fresh content for elcano playlist\")\n   133→\t\t}\n   134→\n   135→\t\t// Rewrite acestream:// URLs\n   136→\t\trewrittenContent := rw.RewriteM3U(content)\n   137→\n   138→\t\t// Set content type\n   139→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   140→\t\tw.WriteHeader(http.StatusOK)\n   141→\t\tw.Write(rewrittenContent)\n   142→\t})\n   143→\n   144→\t// NewEra playlist endpoint\n   145→\thandler.HandleFunc(\"/playlists/newera.m3u\", func(w http.ResponseWriter, r *http.Request) {\n   146→\t\tif r.Method != http.MethodGet {\n   147→\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n   148→\t\t\treturn\n   149→\t\t}\n   150→\n   151→\t\tsourceURL := \"https://ipfs.io/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_fuera_iptv.m3u\"\n   152→\n   153→\t\t// Fetch with cache fallback\n   154→\t\tcontent, fromCache, stale, err := fetch.FetchWithCache(sourceURL)\n   155→\t\tif err != nil {\n   156→\t\t\tlog.Printf(\"Failed to fetch newera playlist: %v\", err)\n   157→\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n   158→\t\t\treturn\n   159→\t\t}\n   160→\n   161→\t\t// Log cache status\n   162→\t\tif fromCache {\n   163→\t\t\tif stale {\n   164→\t\t\t\tlog.Printf(\"Serving stale cache for newera playlist\")\n   165→\t\t\t} else {\n   166→\t\t\t\tlog.Printf(\"Serving fresh cache for newera playlist\")\n   167→\t\t\t}\n   168→\t\t} else {\n   169→\t\t\tlog.Printf(\"Serving fresh content for newera playlist\")\n   170→\t\t}\n   171→\n   172→\t\t// Rewrite acestream:// URLs\n   173→\t\trewrittenContent := rw.RewriteM3U(content)\n   174→\n   175→\t\t// Set content type\n   176→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   177→\t\tw.WriteHeader(http.StatusOK)\n   178→\t\tw.Write(rewrittenContent)\n   179→\t})\n   180→\n   181→\t// Unified playlist endpoint - merges all sources\n   182→\thandler.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n   183→\t\tif r.Method != http.MethodGet {\n   184→\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n   185→\t\t\treturn\n   186→\t\t}\n   187→\n   188→\t\telcanoURL := \"https://ipfs.io/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes_acestream.m3u\"\n   189→\t\tneweraURL := \"https://ipfs.io/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_fuera_iptv.m3u\"\n   190→\n   191→\t\t// Fetch both sources\n   192→\t\telcanoContent, elcanoFromCache, elcanoStale, elcanoErr := fetch.FetchWithCache(elcanoURL)\n   193→\t\tneweraContent, neweraFromCache, neweraStale, neweraErr := fetch.FetchWithCache(neweraURL)\n   194→\n   195→\t\t// Check if both sources failed\n   196→\t\tif elcanoErr != nil && neweraErr != nil {\n   197→\t\t\tlog.Printf(\"Failed to fetch unified playlist - both sources failed: elcano=%v, newera=%v\", elcanoErr, neweraErr)\n   198→\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n   199→\t\t\treturn\n   200→\t\t}\n   201→\n   202→\t\t// Build merged content starting with M3U header\n   203→\t\tvar mergedContent strings.Builder\n   204→\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n   205→\n   206→\t\t// Add elcano content if available\n   207→\t\tif elcanoErr == nil {\n   208→\t\t\t// Log cache status for elcano\n   209→\t\t\tif elcanoFromCache {\n   210→\t\t\t\tif elcanoStale {\n   211→\t\t\t\t\tlog.Printf(\"Using stale cache for elcano in unified playlist\")\n   212→\t\t\t\t} else {\n   213→\t\t\t\t\tlog.Printf(\"Using fresh cache for elcano in unified playlist\")\n   214→\t\t\t\t}\n   215→\t\t\t} else {\n   216→\t\t\t\tlog.Printf(\"Using fresh content for elcano in unified playlist\")\n   217→\t\t\t}\n   218→\n   219→\t\t\t// Parse and add elcano streams (skip header line)\n   220→\t\t\telcanoStr := string(elcanoContent)\n   221→\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n   222→\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n   223→\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n   224→\t\t\t}\n   225→\t\t\tmergedContent.WriteString(elcanoStr)\n   226→\t\t} else {\n   227→\t\t\tlog.Printf(\"Skipping elcano source in unified playlist: %v\", elcanoErr)\n   228→\t\t}\n   229→\n   230→\t\t// Add newera content if available\n   231→\t\tif neweraErr == nil {\n   232→\t\t\t// Log cache status for newera\n   233→\t\t\tif neweraFromCache {\n   234→\t\t\t\tif neweraStale {\n   235→\t\t\t\t\tlog.Printf(\"Using stale cache for newera in unified playlist\")\n   236→\t\t\t\t} else {\n   237→\t\t\t\t\tlog.Printf(\"Using fresh cache for newera in unified playlist\")\n   238→\t\t\t\t}\n   239→\t\t\t} else {\n   240→\t\t\t\tlog.Printf(\"Using fresh content for newera in unified playlist\")\n   241→\t\t\t}\n   242→\n   243→\t\t\t// Parse and add newera streams (skip header line)\n   244→\t\t\tneweraStr := string(neweraContent)\n   245→\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n   246→\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n   247→\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n   248→\t\t\t}\n   249→\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n   250→\t\t\t\tmergedContent.WriteString(\"\\n\")\n   251→\t\t\t}\n   252→\t\t\tmergedContent.WriteString(neweraStr)\n   253→\t\t} else {\n   254→\t\t\tlog.Printf(\"Skipping newera source in unified playlist: %v\", neweraErr)\n   255→\t\t}\n   256→\n   257→\t\t// Apply deduplication by acestream ID (US-003)\n   258→\t\tmergedBytes := []byte(mergedContent.String())\n   259→\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n   260→\n   261→\t\t// Apply alphabetical sorting by display name (US-004)\n   262→\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n   263→\n   264→\t\t// Rewrite acestream:// URLs and remove logos (US-005)\n   265→\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n   266→\n   267→\t\t// Set content type\n   268→\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n   269→\t\tw.WriteHeader(http.StatusOK)\n   270→\t\tw.Write(rewrittenContent)\n   271→\t})\n   272→\n   273→\ts := &http.Server{\n   274→\t\tHandler: handler,\n   275→\t\tAddr:    fmt.Sprintf(\"%s:%s\", cfg.HTTPAddress, cfg.HTTPPort),\n   276→\t}\n   277→\n   278→\tif err := s.ListenAndServe(); err != nil {\n   279→\t\tfmt.Printf(\"Error starting server: %v\\n\", err)\n   280→\t\treturn\n   281→\t}\n   282→}\n   283→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"092fe5c9-b495-47da-bdd4-f907717586f4","tool_use_result":{"type":"text","file":{"filePath":"/home/alorle/gh/alorle/iptv-manager/main.go","content":"package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/alorle/iptv-manager/cache\"\n\t\"github.com/alorle/iptv-manager/fetcher\"\n\t\"github.com/alorle/iptv-manager/rewriter\"\n)\n\ntype Config struct {\n\tHTTPAddress            string\n\tHTTPPort               string\n\tAcestreamPlayerBaseURL string\n\tCacheDir               string\n\tCacheTTL               time.Duration\n}\n\nfunc loadConfig() (*Config, error) {\n\tcfg := &Config{\n\t\tHTTPAddress:            os.Getenv(\"HTTP_ADDRESS\"),\n\t\tHTTPPort:               os.Getenv(\"HTTP_PORT\"),\n\t\tAcestreamPlayerBaseURL: os.Getenv(\"ACESTREAM_PLAYER_BASE_URL\"),\n\t\tCacheDir:               os.Getenv(\"CACHE_DIR\"),\n\t}\n\n\t// Set defaults\n\tif cfg.HTTPAddress == \"\" {\n\t\tcfg.HTTPAddress = \"127.0.0.1\"\n\t}\n\tif cfg.HTTPPort == \"\" {\n\t\tcfg.HTTPPort = \"8080\"\n\t}\n\tif cfg.AcestreamPlayerBaseURL == \"\" {\n\t\tcfg.AcestreamPlayerBaseURL = \"http://127.0.0.1:6878/ace/getstream\"\n\t}\n\n\t// Validate and set CACHE_DIR\n\tif cfg.CacheDir == \"\" {\n\t\treturn nil, fmt.Errorf(\"CACHE_DIR environment variable is required\")\n\t}\n\t// Ensure cache directory is an absolute path\n\tif !filepath.IsAbs(cfg.CacheDir) {\n\t\tabsPath, err := filepath.Abs(cfg.CacheDir)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to resolve absolute path for CACHE_DIR: %w\", err)\n\t\t}\n\t\tcfg.CacheDir = absPath\n\t}\n\n\t// Parse CACHE_TTL\n\tcacheTTLStr := os.Getenv(\"CACHE_TTL\")\n\tif cacheTTLStr == \"\" {\n\t\treturn nil, fmt.Errorf(\"CACHE_TTL environment variable is required\")\n\t}\n\tttl, err := time.ParseDuration(cacheTTLStr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid CACHE_TTL format (expected duration like '1h', '30m'): %w\", err)\n\t}\n\tif ttl <= 0 {\n\t\treturn nil, fmt.Errorf(\"CACHE_TTL must be positive, got: %s\", cacheTTLStr)\n\t}\n\tcfg.CacheTTL = ttl\n\n\treturn cfg, nil\n}\n\nfunc main() {\n\t// Load and validate configuration\n\tcfg, err := loadConfig()\n\tif err != nil {\n\t\tlog.Fatalf(\"Configuration error: %v\", err)\n\t}\n\n\t// Print configuration\n\tfmt.Printf(\"httpAddress: %v\\n\", cfg.HTTPAddress)\n\tfmt.Printf(\"httpPort: %v\\n\", cfg.HTTPPort)\n\tfmt.Printf(\"acestreamPlayerBaseUrl: %v\\n\", cfg.AcestreamPlayerBaseURL)\n\tfmt.Printf(\"cacheDir: %v\\n\", cfg.CacheDir)\n\tfmt.Printf(\"cacheTTL: %v\\n\", cfg.CacheTTL)\n\n\t// Initialize cache storage\n\tstorage, err := cache.NewFileStorage(cfg.CacheDir)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to initialize cache storage: %v\", err)\n\t}\n\n\t// Initialize fetcher with 30 second timeout\n\tfetch := fetcher.New(30*time.Second, storage, cfg.CacheTTL)\n\n\t// Initialize rewriter\n\trw := rewriter.New(cfg.AcestreamPlayerBaseURL)\n\n\thandler := http.NewServeMux()\n\n\thandler.HandleFunc(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\t// Elcano playlist endpoint\n\thandler.HandleFunc(\"/playlists/elcano.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tsourceURL := \"https://ipfs.io/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes_acestream.m3u\"\n\n\t\t// Fetch with cache fallback\n\t\tcontent, fromCache, stale, err := fetch.FetchWithCache(sourceURL)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to fetch elcano playlist: %v\", err)\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\t// Log cache status\n\t\tif fromCache {\n\t\t\tif stale {\n\t\t\t\tlog.Printf(\"Serving stale cache for elcano playlist\")\n\t\t\t} else {\n\t\t\t\tlog.Printf(\"Serving fresh cache for elcano playlist\")\n\t\t\t}\n\t\t} else {\n\t\t\tlog.Printf(\"Serving fresh content for elcano playlist\")\n\t\t}\n\n\t\t// Rewrite acestream:// URLs\n\t\trewrittenContent := rw.RewriteM3U(content)\n\n\t\t// Set content type\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\t// NewEra playlist endpoint\n\thandler.HandleFunc(\"/playlists/newera.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tsourceURL := \"https://ipfs.io/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_fuera_iptv.m3u\"\n\n\t\t// Fetch with cache fallback\n\t\tcontent, fromCache, stale, err := fetch.FetchWithCache(sourceURL)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to fetch newera playlist: %v\", err)\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\t// Log cache status\n\t\tif fromCache {\n\t\t\tif stale {\n\t\t\t\tlog.Printf(\"Serving stale cache for newera playlist\")\n\t\t\t} else {\n\t\t\t\tlog.Printf(\"Serving fresh cache for newera playlist\")\n\t\t\t}\n\t\t} else {\n\t\t\tlog.Printf(\"Serving fresh content for newera playlist\")\n\t\t}\n\n\t\t// Rewrite acestream:// URLs\n\t\trewrittenContent := rw.RewriteM3U(content)\n\n\t\t// Set content type\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\t// Unified playlist endpoint - merges all sources\n\thandler.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\telcanoURL := \"https://ipfs.io/ipns/k51qzi5uqu5di462t7j4vu4akwfhvtjhy88qbupktvoacqfqe9uforjvhyi4wr/hashes_acestream.m3u\"\n\t\tneweraURL := \"https://ipfs.io/ipns/k2k4r8oqlcjxsritt5mczkcn4mmvcmymbqw7113fz2flkrerfwfps004/data/listas/lista_fuera_iptv.m3u\"\n\n\t\t// Fetch both sources\n\t\telcanoContent, elcanoFromCache, elcanoStale, elcanoErr := fetch.FetchWithCache(elcanoURL)\n\t\tneweraContent, neweraFromCache, neweraStale, neweraErr := fetch.FetchWithCache(neweraURL)\n\n\t\t// Check if both sources failed\n\t\tif elcanoErr != nil && neweraErr != nil {\n\t\t\tlog.Printf(\"Failed to fetch unified playlist - both sources failed: elcano=%v, newera=%v\", elcanoErr, neweraErr)\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\t// Build merged content starting with M3U header\n\t\tvar mergedContent strings.Builder\n\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n\n\t\t// Add elcano content if available\n\t\tif elcanoErr == nil {\n\t\t\t// Log cache status for elcano\n\t\t\tif elcanoFromCache {\n\t\t\t\tif elcanoStale {\n\t\t\t\t\tlog.Printf(\"Using stale cache for elcano in unified playlist\")\n\t\t\t\t} else {\n\t\t\t\t\tlog.Printf(\"Using fresh cache for elcano in unified playlist\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.Printf(\"Using fresh content for elcano in unified playlist\")\n\t\t\t}\n\n\t\t\t// Parse and add elcano streams (skip header line)\n\t\t\telcanoStr := string(elcanoContent)\n\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(elcanoStr)\n\t\t} else {\n\t\t\tlog.Printf(\"Skipping elcano source in unified playlist: %v\", elcanoErr)\n\t\t}\n\n\t\t// Add newera content if available\n\t\tif neweraErr == nil {\n\t\t\t// Log cache status for newera\n\t\t\tif neweraFromCache {\n\t\t\t\tif neweraStale {\n\t\t\t\t\tlog.Printf(\"Using stale cache for newera in unified playlist\")\n\t\t\t\t} else {\n\t\t\t\t\tlog.Printf(\"Using fresh cache for newera in unified playlist\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.Printf(\"Using fresh content for newera in unified playlist\")\n\t\t\t}\n\n\t\t\t// Parse and add newera streams (skip header line)\n\t\t\tneweraStr := string(neweraContent)\n\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n\t\t\t}\n\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n\t\t\t\tmergedContent.WriteString(\"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(neweraStr)\n\t\t} else {\n\t\t\tlog.Printf(\"Skipping newera source in unified playlist: %v\", neweraErr)\n\t\t}\n\n\t\t// Apply deduplication by acestream ID (US-003)\n\t\tmergedBytes := []byte(mergedContent.String())\n\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n\n\t\t// Apply alphabetical sorting by display name (US-004)\n\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n\n\t\t// Rewrite acestream:// URLs and remove logos (US-005)\n\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n\n\t\t// Set content type\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ts := &http.Server{\n\t\tHandler: handler,\n\t\tAddr:    fmt.Sprintf(\"%s:%s\", cfg.HTTPAddress, cfg.HTTPPort),\n\t}\n\n\tif err := s.ListenAndServe(); err != nil {\n\t\tfmt.Printf(\"Error starting server: %v\\n\", err)\n\t\treturn\n\t}\n}\n","numLines":283,"startLine":1,"totalLines":283}}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01C8ccDzwBDKWuM6GxDBWvsE","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the rewriter package to understand the deduplication and sorting functions:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":4156,"cache_read_input_tokens":54435,"cache_creation":{"ephemeral_5m_input_tokens":4156,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"5e2dd6a8-142d-4adf-bf42-5b14e4dd3a45"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01C8ccDzwBDKWuM6GxDBWvsE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011tYAeUrdbPZTRpYoiq4Pci","name":"Read","input":{"file_path":"/home/alorle/gh/alorle/iptv-manager/rewriter/rewriter.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":4156,"cache_read_input_tokens":54435,"cache_creation":{"ephemeral_5m_input_tokens":4156,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"4e0bcf44-3749-448e-bdb9-24b3fd79f9b8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011tYAeUrdbPZTRpYoiq4Pci","type":"tool_result","content":"     1→package rewriter\n     2→\n     3→import (\n     4→\t\"fmt\"\n     5→\t\"regexp\"\n     6→\t\"sort\"\n     7→\t\"strings\"\n     8→)\n     9→\n    10→// Rewriter handles URL rewriting for M3U playlists\n    11→type Rewriter struct {\n    12→\tplayerBaseURL string\n    13→}\n    14→\n    15→// New creates a new Rewriter with the specified player base URL\n    16→func New(playerBaseURL string) *Rewriter {\n    17→\treturn &Rewriter{\n    18→\t\tplayerBaseURL: playerBaseURL,\n    19→\t}\n    20→}\n    21→\n    22→var logoRegex = regexp.MustCompile(`\\s*tvg-logo=\"[^\"]*\"`)\n    23→\n    24→// RemoveLogoMetadata removes tvg-logo attribute from EXTINF line while preserving other metadata\n    25→func RemoveLogoMetadata(line string) string {\n    26→\tif !strings.HasPrefix(line, \"#EXTINF:\") {\n    27→\t\treturn line\n    28→\t}\n    29→\n    30→\t// Remove tvg-logo=\"...\" attribute\n    31→\tresult := logoRegex.ReplaceAllString(line, \"\")\n    32→\n    33→\t// Clean up any double spaces that might have been created\n    34→\tfor strings.Contains(result, \"  \") {\n    35→\t\tresult = strings.ReplaceAll(result, \"  \", \" \")\n    36→\t}\n    37→\n    38→\t// Clean up space before comma (when logo was last attribute before display name)\n    39→\tresult = strings.ReplaceAll(result, \" ,\", \",\")\n    40→\n    41→\treturn result\n    42→}\n    43→\n    44→// Stream represents a single M3U playlist entry\n    45→type Stream struct {\n    46→\tMetadata string\n    47→\tURL      string\n    48→\tAceID    string\n    49→}\n    50→\n    51→// ExtractDisplayName extracts the display name from an EXTINF line.\n    52→// Display name is the text after the comma in \"#EXTINF:-1 tvg-id=\"...\" tvg-name=\"...\",Channel Name\"\n    53→// Returns empty string if the line is not an EXTINF line or has no comma.\n    54→func ExtractDisplayName(extinf string) string {\n    55→\tif !strings.HasPrefix(extinf, \"#EXTINF:\") {\n    56→\t\treturn \"\"\n    57→\t}\n    58→\n    59→\t// Find the last comma, as that separates metadata from display name\n    60→\tcommaIdx := strings.LastIndex(extinf, \",\")\n    61→\tif commaIdx == -1 {\n    62→\t\treturn \"\"\n    63→\t}\n    64→\n    65→\t// Extract everything after the comma and trim whitespace\n    66→\tdisplayName := strings.TrimSpace(extinf[commaIdx+1:])\n    67→\treturn displayName\n    68→}\n    69→\n    70→// SortStreamsByName sorts streams alphabetically by display name (case-insensitive).\n    71→// Header lines (lines without URLs) are kept at the top in their original order.\n    72→// Stream entries (metadata + URL pairs) are sorted by the display name extracted from EXTINF.\n    73→func SortStreamsByName(content []byte) []byte {\n    74→\tlines := strings.Split(string(content), \"\\n\")\n    75→\tvar headers []Stream\n    76→\tvar streams []Stream\n    77→\n    78→\t// Parse M3U into header lines and stream entries\n    79→\tfor i := 0; i < len(lines); i++ {\n    80→\t\tline := lines[i]\n    81→\n    82→\t\t// Look for EXTINF metadata lines\n    83→\t\tif strings.HasPrefix(line, \"#EXTINF:\") {\n    84→\t\t\t// Next line should be the URL\n    85→\t\t\tif i+1 < len(lines) {\n    86→\t\t\t\tmetadata := line\n    87→\t\t\t\turl := lines[i+1]\n    88→\t\t\t\ti++ // Skip the URL line in the next iteration\n    89→\n    90→\t\t\t\tstreams = append(streams, Stream{\n    91→\t\t\t\t\tMetadata: metadata,\n    92→\t\t\t\t\tURL:      url,\n    93→\t\t\t\t\tAceID:    \"\", // Not needed for sorting\n    94→\t\t\t\t})\n    95→\t\t\t}\n    96→\t\t} else if line != \"\" {\n    97→\t\t\t// Preserve header lines (like #EXTM3U) and other non-URL lines\n    98→\t\t\theaders = append(headers, Stream{\n    99→\t\t\t\tMetadata: line,\n   100→\t\t\t\tURL:      \"\",\n   101→\t\t\t\tAceID:    \"\",\n   102→\t\t\t})\n   103→\t\t}\n   104→\t}\n   105→\n   106→\t// Sort streams by display name (case-insensitive)\n   107→\tsort.SliceStable(streams, func(i, j int) bool {\n   108→\t\tnameI := strings.ToLower(ExtractDisplayName(streams[i].Metadata))\n   109→\t\tnameJ := strings.ToLower(ExtractDisplayName(streams[j].Metadata))\n   110→\t\treturn nameI < nameJ\n   111→\t})\n   112→\n   113→\t// Rebuild M3U content with headers first, then sorted streams\n   114→\tvar result strings.Builder\n   115→\n   116→\t// Write headers first\n   117→\tfor i, header := range headers {\n   118→\t\tif i > 0 {\n   119→\t\t\tresult.WriteString(\"\\n\")\n   120→\t\t}\n   121→\t\tresult.WriteString(header.Metadata)\n   122→\t}\n   123→\n   124→\t// Write sorted streams\n   125→\tfor _, stream := range streams {\n   126→\t\tif len(headers) > 0 || result.Len() > 0 {\n   127→\t\t\tresult.WriteString(\"\\n\")\n   128→\t\t}\n   129→\t\tresult.WriteString(stream.Metadata)\n   130→\t\tresult.WriteString(\"\\n\")\n   131→\t\tresult.WriteString(stream.URL)\n   132→\t}\n   133→\n   134→\treturn []byte(result.String())\n   135→}\n   136→\n   137→// DeduplicateStreams removes duplicate streams based on acestream ID.\n   138→// For acestream URLs, keeps the first occurrence of each unique ID.\n   139→// Non-acestream URLs are always preserved (no deduplication applied).\n   140→func DeduplicateStreams(content []byte) []byte {\n   141→\tlines := strings.Split(string(content), \"\\n\")\n   142→\tvar streams []Stream\n   143→\tseen := make(map[string]bool)\n   144→\n   145→\t// Parse M3U into stream entries\n   146→\tfor i := 0; i < len(lines); i++ {\n   147→\t\tline := lines[i]\n   148→\n   149→\t\t// Look for EXTINF metadata lines\n   150→\t\tif strings.HasPrefix(line, \"#EXTINF:\") {\n   151→\t\t\t// Next line should be the URL\n   152→\t\t\tif i+1 < len(lines) {\n   153→\t\t\t\tmetadata := line\n   154→\t\t\t\turl := lines[i+1]\n   155→\t\t\t\ti++ // Skip the URL line in the next iteration\n   156→\n   157→\t\t\t\t// Extract acestream ID if this is an acestream URL\n   158→\t\t\t\tvar aceID string\n   159→\t\t\t\tif strings.HasPrefix(url, \"acestream://\") {\n   160→\t\t\t\t\taceID = strings.TrimPrefix(url, \"acestream://\")\n   161→\t\t\t\t\taceID = strings.TrimSpace(aceID)\n   162→\t\t\t\t}\n   163→\n   164→\t\t\t\t// For acestream URLs, deduplicate by ID\n   165→\t\t\t\t// For non-acestream URLs, always keep\n   166→\t\t\t\tif aceID != \"\" {\n   167→\t\t\t\t\tif !seen[aceID] {\n   168→\t\t\t\t\t\tseen[aceID] = true\n   169→\t\t\t\t\t\tstreams = append(streams, Stream{\n   170→\t\t\t\t\t\t\tMetadata: metadata,\n   171→\t\t\t\t\t\t\tURL:      url,\n   172→\t\t\t\t\t\t\tAceID:    aceID,\n   173→\t\t\t\t\t\t})\n   174→\t\t\t\t\t}\n   175→\t\t\t\t\t// Skip duplicate acestream entries\n   176→\t\t\t\t} else {\n   177→\t\t\t\t\t// Always preserve non-acestream URLs\n   178→\t\t\t\t\tstreams = append(streams, Stream{\n   179→\t\t\t\t\t\tMetadata: metadata,\n   180→\t\t\t\t\t\tURL:      url,\n   181→\t\t\t\t\t\tAceID:    \"\",\n   182→\t\t\t\t\t})\n   183→\t\t\t\t}\n   184→\t\t\t}\n   185→\t\t} else if !strings.HasPrefix(line, \"acestream://\") && line != \"\" {\n   186→\t\t\t// Preserve header lines (like #EXTM3U) and other non-URL lines\n   187→\t\t\tstreams = append(streams, Stream{\n   188→\t\t\t\tMetadata: line,\n   189→\t\t\t\tURL:      \"\",\n   190→\t\t\t\tAceID:    \"\",\n   191→\t\t\t})\n   192→\t\t}\n   193→\t}\n   194→\n   195→\t// Rebuild M3U content\n   196→\tvar result strings.Builder\n   197→\tfor i, stream := range streams {\n   198→\t\tif i > 0 {\n   199→\t\t\tresult.WriteString(\"\\n\")\n   200→\t\t}\n   201→\n   202→\t\tif stream.URL != \"\" {\n   203→\t\t\t// This is a complete stream entry with metadata + URL\n   204→\t\t\tresult.WriteString(stream.Metadata)\n   205→\t\t\tresult.WriteString(\"\\n\")\n   206→\t\t\tresult.WriteString(stream.URL)\n   207→\t\t} else {\n   208→\t\t\t// This is a header or other single line\n   209→\t\t\tresult.WriteString(stream.Metadata)\n   210→\t\t}\n   211→\t}\n   212→\n   213→\treturn []byte(result.String())\n   214→}\n   215→\n   216→// RewriteM3U processes M3U content line by line and rewrites acestream:// URLs\n   217→// to player-compatible format\n   218→func (r *Rewriter) RewriteM3U(content []byte) []byte {\n   219→\tlines := strings.Split(string(content), \"\\n\")\n   220→\tvar result strings.Builder\n   221→\n   222→\tfor i, line := range lines {\n   223→\t\t// Add newline for all lines except the first\n   224→\t\tif i > 0 {\n   225→\t\t\tresult.WriteString(\"\\n\")\n   226→\t\t}\n   227→\n   228→\t\t// Check if line starts with acestream://\n   229→\t\tif strings.HasPrefix(line, \"acestream://\") {\n   230→\t\t\t// Extract stream ID from acestream:// URL\n   231→\t\t\tstreamID := strings.TrimPrefix(line, \"acestream://\")\n   232→\t\t\t// Remove any trailing whitespace or carriage return\n   233→\t\t\tstreamID = strings.TrimSpace(streamID)\n   234→\n   235→\t\t\t// Rewrite to player-compatible format with network-caching parameter\n   236→\t\t\trewrittenURL := fmt.Sprintf(\"%s?id=%s&network-caching=1000\", r.playerBaseURL, streamID)\n   237→\t\t\tresult.WriteString(rewrittenURL)\n   238→\t\t} else if strings.HasPrefix(line, \"#EXTINF:\") {\n   239→\t\t\t// Remove logo metadata from EXTINF lines\n   240→\t\t\tresult.WriteString(RemoveLogoMetadata(line))\n   241→\t\t} else {\n   242→\t\t\t// Preserve all other lines unchanged\n   243→\t\t\tresult.WriteString(line)\n   244→\t\t}\n   245→\t}\n   246→\n   247→\treturn []byte(result.String())\n   248→}\n   249→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"cf2c6699-2769-4a58-811b-0fbd8efcd768","tool_use_result":{"type":"text","file":{"filePath":"/home/alorle/gh/alorle/iptv-manager/rewriter/rewriter.go","content":"package rewriter\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// Rewriter handles URL rewriting for M3U playlists\ntype Rewriter struct {\n\tplayerBaseURL string\n}\n\n// New creates a new Rewriter with the specified player base URL\nfunc New(playerBaseURL string) *Rewriter {\n\treturn &Rewriter{\n\t\tplayerBaseURL: playerBaseURL,\n\t}\n}\n\nvar logoRegex = regexp.MustCompile(`\\s*tvg-logo=\"[^\"]*\"`)\n\n// RemoveLogoMetadata removes tvg-logo attribute from EXTINF line while preserving other metadata\nfunc RemoveLogoMetadata(line string) string {\n\tif !strings.HasPrefix(line, \"#EXTINF:\") {\n\t\treturn line\n\t}\n\n\t// Remove tvg-logo=\"...\" attribute\n\tresult := logoRegex.ReplaceAllString(line, \"\")\n\n\t// Clean up any double spaces that might have been created\n\tfor strings.Contains(result, \"  \") {\n\t\tresult = strings.ReplaceAll(result, \"  \", \" \")\n\t}\n\n\t// Clean up space before comma (when logo was last attribute before display name)\n\tresult = strings.ReplaceAll(result, \" ,\", \",\")\n\n\treturn result\n}\n\n// Stream represents a single M3U playlist entry\ntype Stream struct {\n\tMetadata string\n\tURL      string\n\tAceID    string\n}\n\n// ExtractDisplayName extracts the display name from an EXTINF line.\n// Display name is the text after the comma in \"#EXTINF:-1 tvg-id=\"...\" tvg-name=\"...\",Channel Name\"\n// Returns empty string if the line is not an EXTINF line or has no comma.\nfunc ExtractDisplayName(extinf string) string {\n\tif !strings.HasPrefix(extinf, \"#EXTINF:\") {\n\t\treturn \"\"\n\t}\n\n\t// Find the last comma, as that separates metadata from display name\n\tcommaIdx := strings.LastIndex(extinf, \",\")\n\tif commaIdx == -1 {\n\t\treturn \"\"\n\t}\n\n\t// Extract everything after the comma and trim whitespace\n\tdisplayName := strings.TrimSpace(extinf[commaIdx+1:])\n\treturn displayName\n}\n\n// SortStreamsByName sorts streams alphabetically by display name (case-insensitive).\n// Header lines (lines without URLs) are kept at the top in their original order.\n// Stream entries (metadata + URL pairs) are sorted by the display name extracted from EXTINF.\nfunc SortStreamsByName(content []byte) []byte {\n\tlines := strings.Split(string(content), \"\\n\")\n\tvar headers []Stream\n\tvar streams []Stream\n\n\t// Parse M3U into header lines and stream entries\n\tfor i := 0; i < len(lines); i++ {\n\t\tline := lines[i]\n\n\t\t// Look for EXTINF metadata lines\n\t\tif strings.HasPrefix(line, \"#EXTINF:\") {\n\t\t\t// Next line should be the URL\n\t\t\tif i+1 < len(lines) {\n\t\t\t\tmetadata := line\n\t\t\t\turl := lines[i+1]\n\t\t\t\ti++ // Skip the URL line in the next iteration\n\n\t\t\t\tstreams = append(streams, Stream{\n\t\t\t\t\tMetadata: metadata,\n\t\t\t\t\tURL:      url,\n\t\t\t\t\tAceID:    \"\", // Not needed for sorting\n\t\t\t\t})\n\t\t\t}\n\t\t} else if line != \"\" {\n\t\t\t// Preserve header lines (like #EXTM3U) and other non-URL lines\n\t\t\theaders = append(headers, Stream{\n\t\t\t\tMetadata: line,\n\t\t\t\tURL:      \"\",\n\t\t\t\tAceID:    \"\",\n\t\t\t})\n\t\t}\n\t}\n\n\t// Sort streams by display name (case-insensitive)\n\tsort.SliceStable(streams, func(i, j int) bool {\n\t\tnameI := strings.ToLower(ExtractDisplayName(streams[i].Metadata))\n\t\tnameJ := strings.ToLower(ExtractDisplayName(streams[j].Metadata))\n\t\treturn nameI < nameJ\n\t})\n\n\t// Rebuild M3U content with headers first, then sorted streams\n\tvar result strings.Builder\n\n\t// Write headers first\n\tfor i, header := range headers {\n\t\tif i > 0 {\n\t\t\tresult.WriteString(\"\\n\")\n\t\t}\n\t\tresult.WriteString(header.Metadata)\n\t}\n\n\t// Write sorted streams\n\tfor _, stream := range streams {\n\t\tif len(headers) > 0 || result.Len() > 0 {\n\t\t\tresult.WriteString(\"\\n\")\n\t\t}\n\t\tresult.WriteString(stream.Metadata)\n\t\tresult.WriteString(\"\\n\")\n\t\tresult.WriteString(stream.URL)\n\t}\n\n\treturn []byte(result.String())\n}\n\n// DeduplicateStreams removes duplicate streams based on acestream ID.\n// For acestream URLs, keeps the first occurrence of each unique ID.\n// Non-acestream URLs are always preserved (no deduplication applied).\nfunc DeduplicateStreams(content []byte) []byte {\n\tlines := strings.Split(string(content), \"\\n\")\n\tvar streams []Stream\n\tseen := make(map[string]bool)\n\n\t// Parse M3U into stream entries\n\tfor i := 0; i < len(lines); i++ {\n\t\tline := lines[i]\n\n\t\t// Look for EXTINF metadata lines\n\t\tif strings.HasPrefix(line, \"#EXTINF:\") {\n\t\t\t// Next line should be the URL\n\t\t\tif i+1 < len(lines) {\n\t\t\t\tmetadata := line\n\t\t\t\turl := lines[i+1]\n\t\t\t\ti++ // Skip the URL line in the next iteration\n\n\t\t\t\t// Extract acestream ID if this is an acestream URL\n\t\t\t\tvar aceID string\n\t\t\t\tif strings.HasPrefix(url, \"acestream://\") {\n\t\t\t\t\taceID = strings.TrimPrefix(url, \"acestream://\")\n\t\t\t\t\taceID = strings.TrimSpace(aceID)\n\t\t\t\t}\n\n\t\t\t\t// For acestream URLs, deduplicate by ID\n\t\t\t\t// For non-acestream URLs, always keep\n\t\t\t\tif aceID != \"\" {\n\t\t\t\t\tif !seen[aceID] {\n\t\t\t\t\t\tseen[aceID] = true\n\t\t\t\t\t\tstreams = append(streams, Stream{\n\t\t\t\t\t\t\tMetadata: metadata,\n\t\t\t\t\t\t\tURL:      url,\n\t\t\t\t\t\t\tAceID:    aceID,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\t// Skip duplicate acestream entries\n\t\t\t\t} else {\n\t\t\t\t\t// Always preserve non-acestream URLs\n\t\t\t\t\tstreams = append(streams, Stream{\n\t\t\t\t\t\tMetadata: metadata,\n\t\t\t\t\t\tURL:      url,\n\t\t\t\t\t\tAceID:    \"\",\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t} else if !strings.HasPrefix(line, \"acestream://\") && line != \"\" {\n\t\t\t// Preserve header lines (like #EXTM3U) and other non-URL lines\n\t\t\tstreams = append(streams, Stream{\n\t\t\t\tMetadata: line,\n\t\t\t\tURL:      \"\",\n\t\t\t\tAceID:    \"\",\n\t\t\t})\n\t\t}\n\t}\n\n\t// Rebuild M3U content\n\tvar result strings.Builder\n\tfor i, stream := range streams {\n\t\tif i > 0 {\n\t\t\tresult.WriteString(\"\\n\")\n\t\t}\n\n\t\tif stream.URL != \"\" {\n\t\t\t// This is a complete stream entry with metadata + URL\n\t\t\tresult.WriteString(stream.Metadata)\n\t\t\tresult.WriteString(\"\\n\")\n\t\t\tresult.WriteString(stream.URL)\n\t\t} else {\n\t\t\t// This is a header or other single line\n\t\t\tresult.WriteString(stream.Metadata)\n\t\t}\n\t}\n\n\treturn []byte(result.String())\n}\n\n// RewriteM3U processes M3U content line by line and rewrites acestream:// URLs\n// to player-compatible format\nfunc (r *Rewriter) RewriteM3U(content []byte) []byte {\n\tlines := strings.Split(string(content), \"\\n\")\n\tvar result strings.Builder\n\n\tfor i, line := range lines {\n\t\t// Add newline for all lines except the first\n\t\tif i > 0 {\n\t\t\tresult.WriteString(\"\\n\")\n\t\t}\n\n\t\t// Check if line starts with acestream://\n\t\tif strings.HasPrefix(line, \"acestream://\") {\n\t\t\t// Extract stream ID from acestream:// URL\n\t\t\tstreamID := strings.TrimPrefix(line, \"acestream://\")\n\t\t\t// Remove any trailing whitespace or carriage return\n\t\t\tstreamID = strings.TrimSpace(streamID)\n\n\t\t\t// Rewrite to player-compatible format with network-caching parameter\n\t\t\trewrittenURL := fmt.Sprintf(\"%s?id=%s&network-caching=1000\", r.playerBaseURL, streamID)\n\t\t\tresult.WriteString(rewrittenURL)\n\t\t} else if strings.HasPrefix(line, \"#EXTINF:\") {\n\t\t\t// Remove logo metadata from EXTINF lines\n\t\t\tresult.WriteString(RemoveLogoMetadata(line))\n\t\t} else {\n\t\t\t// Preserve all other lines unchanged\n\t\t\tresult.WriteString(line)\n\t\t}\n\t}\n\n\treturn []byte(result.String())\n}\n","numLines":249,"startLine":1,"totalLines":249}}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01SJNSxfyh9Lm6YwuUkmjsV9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JteUYzMdKpsS7NxLCpLLtp","name":"TodoWrite","input":{"todos":[{"content":"Examine existing test patterns in main_test.go","activeForm":"Examining existing test patterns in main_test.go","status":"completed"},{"content":"Review the unified playlist endpoint implementation","activeForm":"Reviewing the unified playlist endpoint implementation","status":"completed"},{"content":"Write integration tests covering all acceptance criteria","activeForm":"Writing integration tests covering all acceptance criteria","status":"in_progress"},{"content":"Run go build ./... to verify build","activeForm":"Running go build ./... to verify build","status":"pending"},{"content":"Run go test ./... to verify all tests pass","activeForm":"Running go test ./... to verify all tests pass","status":"pending"},{"content":"Commit changes with feat message","activeForm":"Committing changes with feat message","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":3147,"cache_read_input_tokens":58591,"cache_creation":{"ephemeral_5m_input_tokens":3147,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"fa282b0f-89f8-4a73-b552-ef4ad9dfb8a3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JteUYzMdKpsS7NxLCpLLtp","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"d49f15ae-cb78-4e6a-afa6-06a711e08b4c","tool_use_result":{"oldTodos":[{"content":"Examine existing test patterns in main_test.go","status":"completed","activeForm":"Examining existing test patterns in main_test.go"},{"content":"Review the unified playlist endpoint implementation","status":"in_progress","activeForm":"Reviewing the unified playlist endpoint implementation"},{"content":"Write integration tests covering all acceptance criteria","status":"pending","activeForm":"Writing integration tests covering all acceptance criteria"},{"content":"Run go build ./... to verify build","status":"pending","activeForm":"Running go build ./... to verify build"},{"content":"Run go test ./... to verify all tests pass","status":"pending","activeForm":"Running go test ./... to verify all tests pass"},{"content":"Commit changes with feat message","status":"pending","activeForm":"Committing changes with feat message"}],"newTodos":[{"content":"Examine existing test patterns in main_test.go","status":"completed","activeForm":"Examining existing test patterns in main_test.go"},{"content":"Review the unified playlist endpoint implementation","status":"completed","activeForm":"Reviewing the unified playlist endpoint implementation"},{"content":"Write integration tests covering all acceptance criteria","status":"in_progress","activeForm":"Writing integration tests covering all acceptance criteria"},{"content":"Run go build ./... to verify build","status":"pending","activeForm":"Running go build ./... to verify build"},{"content":"Run go test ./... to verify all tests pass","status":"pending","activeForm":"Running go test ./... to verify all tests pass"},{"content":"Commit changes with feat message","status":"pending","activeForm":"Committing changes with feat message"}]}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01LY9rFgnFtERctrcEHuV1my","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll add comprehensive integration tests for the unified playlist endpoint. Based on the existing patterns and the acceptance criteria, I'll add tests to main_test.go:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":302,"cache_read_input_tokens":61738,"cache_creation":{"ephemeral_5m_input_tokens":302,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"ca6235e4-b5b9-450b-889e-8fc520c48f42"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01LY9rFgnFtERctrcEHuV1my","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WGvEHu1cyPkUpEuqBsS75r","name":"Edit","input":{"replace_all":false,"file_path":"/home/alorle/gh/alorle/iptv-manager/main_test.go","old_string":"// TestIntegration_RealEndpoints tests the actual elcano and newera endpoints\nfunc TestIntegration_RealEndpoints(t *testing.T) {\n\t// Setup test environment\n\tcacheDir := t.TempDir()\n\n\t// Set environment variables\n\tos.Setenv(\"CACHE_DIR\", cacheDir)\n\tos.Setenv(\"CACHE_TTL\", \"1h\")\n\tos.Setenv(\"HTTP_ADDRESS\", \"127.0.0.1\")\n\tos.Setenv(\"HTTP_PORT\", \"0\") // Use random port\n\tos.Setenv(\"ACESTREAM_PLAYER_BASE_URL\", \"http://127.0.0.1:6878/ace/getstream\")\n\n\tdefer func() {\n\t\tos.Unsetenv(\"CACHE_DIR\")\n\t\tos.Unsetenv(\"CACHE_TTL\")\n\t\tos.Unsetenv(\"HTTP_ADDRESS\")\n\t\tos.Unsetenv(\"HTTP_PORT\")\n\t\tos.Unsetenv(\"ACESTREAM_PLAYER_BASE_URL\")\n\t}()\n\n\t// Load configuration\n\tcfg, err := loadConfig()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to load config: %v\", err)\n\t}\n\n\t// Ensure cache directory is valid\n\tif !filepath.IsAbs(cfg.CacheDir) {\n\t\tt.Fatalf(\"Cache directory must be absolute path, got: %s\", cfg.CacheDir)\n\t}\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cfg.CacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to initialize storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(30*time.Second, storage, cfg.CacheTTL)\n\trw := rewriter.New(cfg.AcestreamPlayerBaseURL)\n\n\t// Create mock IPFS server\n\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n\tdefer mockServer.Close()\n\n\t// Create test server with real endpoint handlers\n\tmux := http.NewServeMux()\n\n\t// Health endpoint\n\tmux.HandleFunc(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\t// Elcano endpoint (modified to use mock server)\n\tmux.HandleFunc(\"/playlists/elcano.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\t// NewEra endpoint (modified to use mock server)\n\tmux.HandleFunc(\"/playlists/newera.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Test health endpoint\n\tt.Run(\"Health endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/health\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request health endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tbody := make([]byte, 10)\n\t\tn, _ := resp.Body.Read(body)\n\t\tif string(body[:n]) != \"OK\" {\n\t\t\tt.Errorf(\"Expected body 'OK', got '%s'\", string(body[:n]))\n\t\t}\n\t})\n\n\t// Test elcano endpoint\n\tt.Run(\"Elcano endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/playlists/elcano.m3u\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request elcano endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tcontentType := resp.Header.Get(\"Content-Type\")\n\t\tif contentType != \"audio/x-mpegurl\" {\n\t\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t\t}\n\n\t\tbody := make([]byte, 4096)\n\t\tn, _ := resp.Body.Read(body)\n\t\tbodyStr := string(body[:n])\n\n\t\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=\") {\n\t\t\tt.Error(\"Expected rewritten acestream URLs\")\n\t\t}\n\t})\n\n\t// Test newera endpoint\n\tt.Run(\"NewEra endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/playlists/newera.m3u\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request newera endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tcontentType := resp.Header.Get(\"Content-Type\")\n\t\tif contentType != \"audio/x-mpegurl\" {\n\t\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t\t}\n\n\t\tbody := make([]byte, 4096)\n\t\tn, _ := resp.Body.Read(body)\n\t\tbodyStr := string(body[:n])\n\n\t\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=\") {\n\t\t\tt.Error(\"Expected rewritten acestream URLs\")\n\t\t}\n\t})\n}","new_string":"// TestIntegration_RealEndpoints tests the actual elcano and newera endpoints\nfunc TestIntegration_RealEndpoints(t *testing.T) {\n\t// Setup test environment\n\tcacheDir := t.TempDir()\n\n\t// Set environment variables\n\tos.Setenv(\"CACHE_DIR\", cacheDir)\n\tos.Setenv(\"CACHE_TTL\", \"1h\")\n\tos.Setenv(\"HTTP_ADDRESS\", \"127.0.0.1\")\n\tos.Setenv(\"HTTP_PORT\", \"0\") // Use random port\n\tos.Setenv(\"ACESTREAM_PLAYER_BASE_URL\", \"http://127.0.0.1:6878/ace/getstream\")\n\n\tdefer func() {\n\t\tos.Unsetenv(\"CACHE_DIR\")\n\t\tos.Unsetenv(\"CACHE_TTL\")\n\t\tos.Unsetenv(\"HTTP_ADDRESS\")\n\t\tos.Unsetenv(\"HTTP_PORT\")\n\t\tos.Unsetenv(\"ACESTREAM_PLAYER_BASE_URL\")\n\t}()\n\n\t// Load configuration\n\tcfg, err := loadConfig()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to load config: %v\", err)\n\t}\n\n\t// Ensure cache directory is valid\n\tif !filepath.IsAbs(cfg.CacheDir) {\n\t\tt.Fatalf(\"Cache directory must be absolute path, got: %s\", cfg.CacheDir)\n\t}\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cfg.CacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to initialize storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(30*time.Second, storage, cfg.CacheTTL)\n\trw := rewriter.New(cfg.AcestreamPlayerBaseURL)\n\n\t// Create mock IPFS server\n\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n\tdefer mockServer.Close()\n\n\t// Create test server with real endpoint handlers\n\tmux := http.NewServeMux()\n\n\t// Health endpoint\n\tmux.HandleFunc(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\t// Elcano endpoint (modified to use mock server)\n\tmux.HandleFunc(\"/playlists/elcano.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\t// NewEra endpoint (modified to use mock server)\n\tmux.HandleFunc(\"/playlists/newera.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Test health endpoint\n\tt.Run(\"Health endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/health\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request health endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tbody := make([]byte, 10)\n\t\tn, _ := resp.Body.Read(body)\n\t\tif string(body[:n]) != \"OK\" {\n\t\t\tt.Errorf(\"Expected body 'OK', got '%s'\", string(body[:n]))\n\t\t}\n\t})\n\n\t// Test elcano endpoint\n\tt.Run(\"Elcano endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/playlists/elcano.m3u\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request elcano endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tcontentType := resp.Header.Get(\"Content-Type\")\n\t\tif contentType != \"audio/x-mpegurl\" {\n\t\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t\t}\n\n\t\tbody := make([]byte, 4096)\n\t\tn, _ := resp.Body.Read(body)\n\t\tbodyStr := string(body[:n])\n\n\t\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=\") {\n\t\t\tt.Error(\"Expected rewritten acestream URLs\")\n\t\t}\n\t})\n\n\t// Test newera endpoint\n\tt.Run(\"NewEra endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/playlists/newera.m3u\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request newera endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tcontentType := resp.Header.Get(\"Content-Type\")\n\t\tif contentType != \"audio/x-mpegurl\" {\n\t\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t\t}\n\n\t\tbody := make([]byte, 4096)\n\t\tn, _ := resp.Body.Read(body)\n\t\tbodyStr := string(body[:n])\n\n\t\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=\") {\n\t\t\tt.Error(\"Expected rewritten acestream URLs\")\n\t\t}\n\t})\n}\n\n// TestIntegration_UnifiedPlaylist_SuccessfulFetchAndMerge tests unified playlist endpoint\n// with successful fetch and merge from both sources\nfunc TestIntegration_UnifiedPlaylist_SuccessfulFetchAndMerge(t *testing.T) {\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\t// Create mock content for elcano source\n\telcanoContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"e1\" tvg-name=\"Elcano One\" tvg-logo=\"http://example.com/logo1.png\" group-title=\"Sports\",Elcano One\nacestream://1111111111111111111111111111111111111111\n#EXTINF:-1 tvg-id=\"e2\" tvg-name=\"Elcano Two\",Elcano Two\nacestream://2222222222222222222222222222222222222222\n`\n\n\t// Create mock content for newera source\n\tneweraContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"NewEra One\" tvg-logo=\"http://example.com/logo2.png\",NewEra One\nacestream://3333333333333333333333333333333333333333\n#EXTINF:-1 tvg-id=\"n2\" tvg-name=\"NewEra Two\",NewEra Two\nacestream://4444444444444444444444444444444444444444\n`\n\n\t// Create mock servers\n\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n\tdefer elcanoServer.Close()\n\n\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n\tdefer neweraServer.Close()\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t// Create test server with unified endpoint\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\t// Fetch both sources\n\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n\n\t\t// Check if both sources failed\n\t\tif elcanoErr != nil && neweraErr != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\t// Build merged content\n\t\tvar mergedContent strings.Builder\n\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n\n\t\tif elcanoErr == nil {\n\t\t\telcanoStr := string(elcanoContentBytes)\n\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(elcanoStr)\n\t\t}\n\n\t\tif neweraErr == nil {\n\t\t\tneweraStr := string(neweraContentBytes)\n\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n\t\t\t}\n\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n\t\t\t\tmergedContent.WriteString(\"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(neweraStr)\n\t\t}\n\n\t\t// Apply deduplication, sorting, and rewriting\n\t\tmergedBytes := []byte(mergedContent.String())\n\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Make request\n\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t}\n\n\tbody := make([]byte, 8192)\n\tn, _ := resp.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify all streams from both sources are present\n\tif !strings.Contains(bodyStr, \"Elcano One\") {\n\t\tt.Error(\"Expected 'Elcano One' from elcano source\")\n\t}\n\tif !strings.Contains(bodyStr, \"Elcano Two\") {\n\t\tt.Error(\"Expected 'Elcano Two' from elcano source\")\n\t}\n\tif !strings.Contains(bodyStr, \"NewEra One\") {\n\t\tt.Error(\"Expected 'NewEra One' from newera source\")\n\t}\n\tif !strings.Contains(bodyStr, \"NewEra Two\") {\n\t\tt.Error(\"Expected 'NewEra Two' from newera source\")\n\t}\n\n\t// Verify URLs are rewritten\n\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=1111111111111111111111111111111111111111\") {\n\t\tt.Error(\"Expected rewritten URL for stream 1\")\n\t}\n\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=3333333333333333333333333333333333333333\") {\n\t\tt.Error(\"Expected rewritten URL for stream 3\")\n\t}\n}\n\n// TestIntegration_UnifiedPlaylist_Deduplication tests that duplicate streams are removed\nfunc TestIntegration_UnifiedPlaylist_Deduplication(t *testing.T) {\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\t// Create mock content with duplicate acestream IDs\n\telcanoContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"e1\" tvg-name=\"Channel A\",Channel A\nacestream://1111111111111111111111111111111111111111\n#EXTINF:-1 tvg-id=\"e2\" tvg-name=\"Channel B\",Channel B\nacestream://2222222222222222222222222222222222222222\n`\n\n\tneweraContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"Channel A Duplicate\",Channel A Duplicate\nacestream://1111111111111111111111111111111111111111\n#EXTINF:-1 tvg-id=\"n2\" tvg-name=\"Channel C\",Channel C\nacestream://3333333333333333333333333333333333333333\n`\n\n\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n\tdefer elcanoServer.Close()\n\n\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n\tdefer neweraServer.Close()\n\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n\n\t\tif elcanoErr != nil && neweraErr != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\tvar mergedContent strings.Builder\n\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n\n\t\tif elcanoErr == nil {\n\t\t\telcanoStr := string(elcanoContentBytes)\n\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(elcanoStr)\n\t\t}\n\n\t\tif neweraErr == nil {\n\t\t\tneweraStr := string(neweraContentBytes)\n\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n\t\t\t}\n\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n\t\t\t\tmergedContent.WriteString(\"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(neweraStr)\n\t\t}\n\n\t\tmergedBytes := []byte(mergedContent.String())\n\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody := make([]byte, 8192)\n\tn, _ := resp.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Count occurrences of the duplicate stream ID\n\tduplicateCount := strings.Count(bodyStr, \"id=1111111111111111111111111111111111111111\")\n\tif duplicateCount != 1 {\n\t\tt.Errorf(\"Expected duplicate stream ID to appear once, but found %d occurrences\", duplicateCount)\n\t}\n\n\t// Verify first occurrence is kept\n\tif !strings.Contains(bodyStr, \"Channel A\") {\n\t\tt.Error(\"Expected first occurrence 'Channel A' to be preserved\")\n\t}\n\n\t// Verify duplicate is removed\n\tif strings.Contains(bodyStr, \"Channel A Duplicate\") {\n\t\tt.Error(\"Expected duplicate 'Channel A Duplicate' to be removed\")\n\t}\n\n\t// Verify other unique streams are present\n\tif !strings.Contains(bodyStr, \"Channel B\") {\n\t\tt.Error(\"Expected 'Channel B' to be present\")\n\t}\n\tif !strings.Contains(bodyStr, \"Channel C\") {\n\t\tt.Error(\"Expected 'Channel C' to be present\")\n\t}\n}\n\n// TestIntegration_UnifiedPlaylist_AlphabeticalSorting tests alphabetical sorting by display name\nfunc TestIntegration_UnifiedPlaylist_AlphabeticalSorting(t *testing.T) {\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\t// Create mock content with unsorted names\n\telcanoContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"e1\",Zebra Channel\nacestream://1111111111111111111111111111111111111111\n#EXTINF:-1 tvg-id=\"e2\",Alpha Channel\nacestream://2222222222222222222222222222222222222222\n`\n\n\tneweraContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"n1\",Beta Channel\nacestream://3333333333333333333333333333333333333333\n#EXTINF:-1 tvg-id=\"n2\",Gamma Channel\nacestream://4444444444444444444444444444444444444444\n`\n\n\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n\tdefer elcanoServer.Close()\n\n\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n\tdefer neweraServer.Close()\n\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n\n\t\tif elcanoErr != nil && neweraErr != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\tvar mergedContent strings.Builder\n\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n\n\t\tif elcanoErr == nil {\n\t\t\telcanoStr := string(elcanoContentBytes)\n\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(elcanoStr)\n\t\t}\n\n\t\tif neweraErr == nil {\n\t\t\tneweraStr := string(neweraContentBytes)\n\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n\t\t\t}\n\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n\t\t\t\tmergedContent.WriteString(\"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(neweraStr)\n\t\t}\n\n\t\tmergedBytes := []byte(mergedContent.String())\n\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody := make([]byte, 8192)\n\tn, _ := resp.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Find positions of channel names\n\talphaPos := strings.Index(bodyStr, \"Alpha Channel\")\n\tbetaPos := strings.Index(bodyStr, \"Beta Channel\")\n\tgammaPos := strings.Index(bodyStr, \"Gamma Channel\")\n\tzebraPos := strings.Index(bodyStr, \"Zebra Channel\")\n\n\t// Verify alphabetical order\n\tif alphaPos == -1 || betaPos == -1 || gammaPos == -1 || zebraPos == -1 {\n\t\tt.Fatal(\"Not all channels found in response\")\n\t}\n\n\tif !(alphaPos < betaPos && betaPos < gammaPos && gammaPos < zebraPos) {\n\t\tt.Errorf(\"Channels not in alphabetical order. Positions: Alpha=%d, Beta=%d, Gamma=%d, Zebra=%d\",\n\t\t\talphaPos, betaPos, gammaPos, zebraPos)\n\t}\n}\n\n// TestIntegration_UnifiedPlaylist_LogoRemoval tests that tvg-logo attributes are removed\nfunc TestIntegration_UnifiedPlaylist_LogoRemoval(t *testing.T) {\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\telcanoContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"e1\" tvg-logo=\"http://example.com/logo1.png\" tvg-name=\"Channel One\",Channel One\nacestream://1111111111111111111111111111111111111111\n`\n\n\tneweraContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"Channel Two\" tvg-logo=\"http://example.com/logo2.png\",Channel Two\nacestream://2222222222222222222222222222222222222222\n`\n\n\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n\tdefer elcanoServer.Close()\n\n\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n\tdefer neweraServer.Close()\n\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n\n\t\tif elcanoErr != nil && neweraErr != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\tvar mergedContent strings.Builder\n\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n\n\t\tif elcanoErr == nil {\n\t\t\telcanoStr := string(elcanoContentBytes)\n\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(elcanoStr)\n\t\t}\n\n\t\tif neweraErr == nil {\n\t\t\tneweraStr := string(neweraContentBytes)\n\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n\t\t\t}\n\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n\t\t\t\tmergedContent.WriteString(\"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(neweraStr)\n\t\t}\n\n\t\tmergedBytes := []byte(mergedContent.String())\n\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody := make([]byte, 8192)\n\tn, _ := resp.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify logos are removed\n\tif strings.Contains(bodyStr, \"tvg-logo=\") {\n\t\tt.Error(\"Expected tvg-logo attributes to be removed\")\n\t}\n\tif strings.Contains(bodyStr, \"logo1.png\") {\n\t\tt.Error(\"Expected logo1.png to be removed\")\n\t}\n\tif strings.Contains(bodyStr, \"logo2.png\") {\n\t\tt.Error(\"Expected logo2.png to be removed\")\n\t}\n\n\t// Verify other metadata is preserved\n\tif !strings.Contains(bodyStr, \"tvg-id=\\\"e1\\\"\") {\n\t\tt.Error(\"Expected tvg-id to be preserved\")\n\t}\n\tif !strings.Contains(bodyStr, \"tvg-name=\\\"Channel One\\\"\") {\n\t\tt.Error(\"Expected tvg-name to be preserved\")\n\t}\n}\n\n// TestIntegration_UnifiedPlaylist_NetworkCachingParameter tests network-caching parameter in URLs\nfunc TestIntegration_UnifiedPlaylist_NetworkCachingParameter(t *testing.T) {\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\telcanoContent := `#EXTM3U\n#EXTINF:-1,Test Channel\nacestream://1111111111111111111111111111111111111111\n`\n\n\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n\tdefer elcanoServer.Close()\n\n\tneweraServer := createMockIPFSServer(t, true, \"\") // Failing server\n\tdefer neweraServer.Close()\n\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n\t\t_, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n\n\t\tif elcanoErr != nil && neweraErr != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\tvar mergedContent strings.Builder\n\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n\n\t\tif elcanoErr == nil {\n\t\t\telcanoStr := string(elcanoContentBytes)\n\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(elcanoStr)\n\t\t}\n\n\t\tmergedBytes := []byte(mergedContent.String())\n\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody := make([]byte, 8192)\n\tn, _ := resp.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify network-caching parameter is present\n\tif !strings.Contains(bodyStr, \"network-caching=1000\") {\n\t\tt.Error(\"Expected network-caching=1000 parameter in rewritten acestream URLs\")\n\t}\n\n\t// Verify complete URL format\n\texpectedURL := \"http://127.0.0.1:6878/ace/getstream?id=1111111111111111111111111111111111111111&network-caching=1000\"\n\tif !strings.Contains(bodyStr, expectedURL) {\n\t\tt.Errorf(\"Expected URL with network-caching parameter: %s\", expectedURL)\n\t}\n}\n\n// TestIntegration_UnifiedPlaylist_CacheFallback tests cache fallback when sources fail\nfunc TestIntegration_UnifiedPlaylist_CacheFallback(t *testing.T) {\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\telcanoContent := `#EXTM3U\n#EXTINF:-1,Cached Channel\nacestream://1111111111111111111111111111111111111111\n`\n\n\telcanoAvailable := true\n\telcanoServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif !elcanoAvailable {\n\t\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(elcanoContent))\n\t}))\n\tdefer elcanoServer.Close()\n\n\tneweraServer := createMockIPFSServer(t, true, \"\") // Always failing\n\tdefer neweraServer.Close()\n\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 100*time.Millisecond) // Short TTL\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n\t\t_, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n\n\t\tif elcanoErr != nil && neweraErr != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\tvar mergedContent strings.Builder\n\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n\n\t\tif elcanoErr == nil {\n\t\t\telcanoStr := string(elcanoContentBytes)\n\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(elcanoStr)\n\t\t}\n\n\t\tmergedBytes := []byte(mergedContent.String())\n\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// First request - populate cache\n\tresp1, err := http.Get(testServer.URL + \"/playlist.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make first request: %v\", err)\n\t}\n\tresp1.Body.Close()\n\n\tif resp1.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"Expected status code %d for first request, got %d\", http.StatusOK, resp1.StatusCode)\n\t}\n\n\t// Wait for cache to expire\n\ttime.Sleep(150 * time.Millisecond)\n\n\t// Make elcano unavailable\n\telcanoAvailable = false\n\n\t// Second request - should serve stale cache\n\tresp2, err := http.Get(testServer.URL + \"/playlist.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make second request: %v\", err)\n\t}\n\tdefer resp2.Body.Close()\n\n\tif resp2.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"Expected status code %d when serving stale cache, got %d\", http.StatusOK, resp2.StatusCode)\n\t}\n\n\tbody := make([]byte, 8192)\n\tn, _ := resp2.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify stale cache content is served\n\tif !strings.Contains(bodyStr, \"Cached Channel\") {\n\t\tt.Error(\"Expected stale cache content to be served\")\n\t}\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":302,"cache_read_input_tokens":61738,"cache_creation":{"ephemeral_5m_input_tokens":302,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"354622b8-4de1-45d7-85cb-7cf3703b2fdc"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WGvEHu1cyPkUpEuqBsS75r","type":"tool_result","content":"The file /home/alorle/gh/alorle/iptv-manager/main_test.go has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"e01b36c5-0b94-4a52-b67f-4d13154dd7d5","tool_use_result":{"filePath":"/home/alorle/gh/alorle/iptv-manager/main_test.go","oldString":"// TestIntegration_RealEndpoints tests the actual elcano and newera endpoints\nfunc TestIntegration_RealEndpoints(t *testing.T) {\n\t// Setup test environment\n\tcacheDir := t.TempDir()\n\n\t// Set environment variables\n\tos.Setenv(\"CACHE_DIR\", cacheDir)\n\tos.Setenv(\"CACHE_TTL\", \"1h\")\n\tos.Setenv(\"HTTP_ADDRESS\", \"127.0.0.1\")\n\tos.Setenv(\"HTTP_PORT\", \"0\") // Use random port\n\tos.Setenv(\"ACESTREAM_PLAYER_BASE_URL\", \"http://127.0.0.1:6878/ace/getstream\")\n\n\tdefer func() {\n\t\tos.Unsetenv(\"CACHE_DIR\")\n\t\tos.Unsetenv(\"CACHE_TTL\")\n\t\tos.Unsetenv(\"HTTP_ADDRESS\")\n\t\tos.Unsetenv(\"HTTP_PORT\")\n\t\tos.Unsetenv(\"ACESTREAM_PLAYER_BASE_URL\")\n\t}()\n\n\t// Load configuration\n\tcfg, err := loadConfig()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to load config: %v\", err)\n\t}\n\n\t// Ensure cache directory is valid\n\tif !filepath.IsAbs(cfg.CacheDir) {\n\t\tt.Fatalf(\"Cache directory must be absolute path, got: %s\", cfg.CacheDir)\n\t}\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cfg.CacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to initialize storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(30*time.Second, storage, cfg.CacheTTL)\n\trw := rewriter.New(cfg.AcestreamPlayerBaseURL)\n\n\t// Create mock IPFS server\n\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n\tdefer mockServer.Close()\n\n\t// Create test server with real endpoint handlers\n\tmux := http.NewServeMux()\n\n\t// Health endpoint\n\tmux.HandleFunc(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\t// Elcano endpoint (modified to use mock server)\n\tmux.HandleFunc(\"/playlists/elcano.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\t// NewEra endpoint (modified to use mock server)\n\tmux.HandleFunc(\"/playlists/newera.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Test health endpoint\n\tt.Run(\"Health endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/health\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request health endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tbody := make([]byte, 10)\n\t\tn, _ := resp.Body.Read(body)\n\t\tif string(body[:n]) != \"OK\" {\n\t\t\tt.Errorf(\"Expected body 'OK', got '%s'\", string(body[:n]))\n\t\t}\n\t})\n\n\t// Test elcano endpoint\n\tt.Run(\"Elcano endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/playlists/elcano.m3u\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request elcano endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tcontentType := resp.Header.Get(\"Content-Type\")\n\t\tif contentType != \"audio/x-mpegurl\" {\n\t\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t\t}\n\n\t\tbody := make([]byte, 4096)\n\t\tn, _ := resp.Body.Read(body)\n\t\tbodyStr := string(body[:n])\n\n\t\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=\") {\n\t\t\tt.Error(\"Expected rewritten acestream URLs\")\n\t\t}\n\t})\n\n\t// Test newera endpoint\n\tt.Run(\"NewEra endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/playlists/newera.m3u\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request newera endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tcontentType := resp.Header.Get(\"Content-Type\")\n\t\tif contentType != \"audio/x-mpegurl\" {\n\t\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t\t}\n\n\t\tbody := make([]byte, 4096)\n\t\tn, _ := resp.Body.Read(body)\n\t\tbodyStr := string(body[:n])\n\n\t\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=\") {\n\t\t\tt.Error(\"Expected rewritten acestream URLs\")\n\t\t}\n\t})\n}","newString":"// TestIntegration_RealEndpoints tests the actual elcano and newera endpoints\nfunc TestIntegration_RealEndpoints(t *testing.T) {\n\t// Setup test environment\n\tcacheDir := t.TempDir()\n\n\t// Set environment variables\n\tos.Setenv(\"CACHE_DIR\", cacheDir)\n\tos.Setenv(\"CACHE_TTL\", \"1h\")\n\tos.Setenv(\"HTTP_ADDRESS\", \"127.0.0.1\")\n\tos.Setenv(\"HTTP_PORT\", \"0\") // Use random port\n\tos.Setenv(\"ACESTREAM_PLAYER_BASE_URL\", \"http://127.0.0.1:6878/ace/getstream\")\n\n\tdefer func() {\n\t\tos.Unsetenv(\"CACHE_DIR\")\n\t\tos.Unsetenv(\"CACHE_TTL\")\n\t\tos.Unsetenv(\"HTTP_ADDRESS\")\n\t\tos.Unsetenv(\"HTTP_PORT\")\n\t\tos.Unsetenv(\"ACESTREAM_PLAYER_BASE_URL\")\n\t}()\n\n\t// Load configuration\n\tcfg, err := loadConfig()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to load config: %v\", err)\n\t}\n\n\t// Ensure cache directory is valid\n\tif !filepath.IsAbs(cfg.CacheDir) {\n\t\tt.Fatalf(\"Cache directory must be absolute path, got: %s\", cfg.CacheDir)\n\t}\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cfg.CacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to initialize storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(30*time.Second, storage, cfg.CacheTTL)\n\trw := rewriter.New(cfg.AcestreamPlayerBaseURL)\n\n\t// Create mock IPFS server\n\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n\tdefer mockServer.Close()\n\n\t// Create test server with real endpoint handlers\n\tmux := http.NewServeMux()\n\n\t// Health endpoint\n\tmux.HandleFunc(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\t// Elcano endpoint (modified to use mock server)\n\tmux.HandleFunc(\"/playlists/elcano.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\t// NewEra endpoint (modified to use mock server)\n\tmux.HandleFunc(\"/playlists/newera.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Test health endpoint\n\tt.Run(\"Health endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/health\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request health endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tbody := make([]byte, 10)\n\t\tn, _ := resp.Body.Read(body)\n\t\tif string(body[:n]) != \"OK\" {\n\t\t\tt.Errorf(\"Expected body 'OK', got '%s'\", string(body[:n]))\n\t\t}\n\t})\n\n\t// Test elcano endpoint\n\tt.Run(\"Elcano endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/playlists/elcano.m3u\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request elcano endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tcontentType := resp.Header.Get(\"Content-Type\")\n\t\tif contentType != \"audio/x-mpegurl\" {\n\t\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t\t}\n\n\t\tbody := make([]byte, 4096)\n\t\tn, _ := resp.Body.Read(body)\n\t\tbodyStr := string(body[:n])\n\n\t\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=\") {\n\t\t\tt.Error(\"Expected rewritten acestream URLs\")\n\t\t}\n\t})\n\n\t// Test newera endpoint\n\tt.Run(\"NewEra endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/playlists/newera.m3u\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request newera endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tcontentType := resp.Header.Get(\"Content-Type\")\n\t\tif contentType != \"audio/x-mpegurl\" {\n\t\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t\t}\n\n\t\tbody := make([]byte, 4096)\n\t\tn, _ := resp.Body.Read(body)\n\t\tbodyStr := string(body[:n])\n\n\t\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=\") {\n\t\t\tt.Error(\"Expected rewritten acestream URLs\")\n\t\t}\n\t})\n}\n\n// TestIntegration_UnifiedPlaylist_SuccessfulFetchAndMerge tests unified playlist endpoint\n// with successful fetch and merge from both sources\nfunc TestIntegration_UnifiedPlaylist_SuccessfulFetchAndMerge(t *testing.T) {\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\t// Create mock content for elcano source\n\telcanoContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"e1\" tvg-name=\"Elcano One\" tvg-logo=\"http://example.com/logo1.png\" group-title=\"Sports\",Elcano One\nacestream://1111111111111111111111111111111111111111\n#EXTINF:-1 tvg-id=\"e2\" tvg-name=\"Elcano Two\",Elcano Two\nacestream://2222222222222222222222222222222222222222\n`\n\n\t// Create mock content for newera source\n\tneweraContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"NewEra One\" tvg-logo=\"http://example.com/logo2.png\",NewEra One\nacestream://3333333333333333333333333333333333333333\n#EXTINF:-1 tvg-id=\"n2\" tvg-name=\"NewEra Two\",NewEra Two\nacestream://4444444444444444444444444444444444444444\n`\n\n\t// Create mock servers\n\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n\tdefer elcanoServer.Close()\n\n\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n\tdefer neweraServer.Close()\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t// Create test server with unified endpoint\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\t// Fetch both sources\n\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n\n\t\t// Check if both sources failed\n\t\tif elcanoErr != nil && neweraErr != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\t// Build merged content\n\t\tvar mergedContent strings.Builder\n\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n\n\t\tif elcanoErr == nil {\n\t\t\telcanoStr := string(elcanoContentBytes)\n\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(elcanoStr)\n\t\t}\n\n\t\tif neweraErr == nil {\n\t\t\tneweraStr := string(neweraContentBytes)\n\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n\t\t\t}\n\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n\t\t\t\tmergedContent.WriteString(\"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(neweraStr)\n\t\t}\n\n\t\t// Apply deduplication, sorting, and rewriting\n\t\tmergedBytes := []byte(mergedContent.String())\n\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Make request\n\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t}\n\n\tbody := make([]byte, 8192)\n\tn, _ := resp.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify all streams from both sources are present\n\tif !strings.Contains(bodyStr, \"Elcano One\") {\n\t\tt.Error(\"Expected 'Elcano One' from elcano source\")\n\t}\n\tif !strings.Contains(bodyStr, \"Elcano Two\") {\n\t\tt.Error(\"Expected 'Elcano Two' from elcano source\")\n\t}\n\tif !strings.Contains(bodyStr, \"NewEra One\") {\n\t\tt.Error(\"Expected 'NewEra One' from newera source\")\n\t}\n\tif !strings.Contains(bodyStr, \"NewEra Two\") {\n\t\tt.Error(\"Expected 'NewEra Two' from newera source\")\n\t}\n\n\t// Verify URLs are rewritten\n\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=1111111111111111111111111111111111111111\") {\n\t\tt.Error(\"Expected rewritten URL for stream 1\")\n\t}\n\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=3333333333333333333333333333333333333333\") {\n\t\tt.Error(\"Expected rewritten URL for stream 3\")\n\t}\n}\n\n// TestIntegration_UnifiedPlaylist_Deduplication tests that duplicate streams are removed\nfunc TestIntegration_UnifiedPlaylist_Deduplication(t *testing.T) {\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\t// Create mock content with duplicate acestream IDs\n\telcanoContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"e1\" tvg-name=\"Channel A\",Channel A\nacestream://1111111111111111111111111111111111111111\n#EXTINF:-1 tvg-id=\"e2\" tvg-name=\"Channel B\",Channel B\nacestream://2222222222222222222222222222222222222222\n`\n\n\tneweraContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"Channel A Duplicate\",Channel A Duplicate\nacestream://1111111111111111111111111111111111111111\n#EXTINF:-1 tvg-id=\"n2\" tvg-name=\"Channel C\",Channel C\nacestream://3333333333333333333333333333333333333333\n`\n\n\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n\tdefer elcanoServer.Close()\n\n\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n\tdefer neweraServer.Close()\n\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n\n\t\tif elcanoErr != nil && neweraErr != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\tvar mergedContent strings.Builder\n\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n\n\t\tif elcanoErr == nil {\n\t\t\telcanoStr := string(elcanoContentBytes)\n\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(elcanoStr)\n\t\t}\n\n\t\tif neweraErr == nil {\n\t\t\tneweraStr := string(neweraContentBytes)\n\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n\t\t\t}\n\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n\t\t\t\tmergedContent.WriteString(\"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(neweraStr)\n\t\t}\n\n\t\tmergedBytes := []byte(mergedContent.String())\n\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody := make([]byte, 8192)\n\tn, _ := resp.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Count occurrences of the duplicate stream ID\n\tduplicateCount := strings.Count(bodyStr, \"id=1111111111111111111111111111111111111111\")\n\tif duplicateCount != 1 {\n\t\tt.Errorf(\"Expected duplicate stream ID to appear once, but found %d occurrences\", duplicateCount)\n\t}\n\n\t// Verify first occurrence is kept\n\tif !strings.Contains(bodyStr, \"Channel A\") {\n\t\tt.Error(\"Expected first occurrence 'Channel A' to be preserved\")\n\t}\n\n\t// Verify duplicate is removed\n\tif strings.Contains(bodyStr, \"Channel A Duplicate\") {\n\t\tt.Error(\"Expected duplicate 'Channel A Duplicate' to be removed\")\n\t}\n\n\t// Verify other unique streams are present\n\tif !strings.Contains(bodyStr, \"Channel B\") {\n\t\tt.Error(\"Expected 'Channel B' to be present\")\n\t}\n\tif !strings.Contains(bodyStr, \"Channel C\") {\n\t\tt.Error(\"Expected 'Channel C' to be present\")\n\t}\n}\n\n// TestIntegration_UnifiedPlaylist_AlphabeticalSorting tests alphabetical sorting by display name\nfunc TestIntegration_UnifiedPlaylist_AlphabeticalSorting(t *testing.T) {\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\t// Create mock content with unsorted names\n\telcanoContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"e1\",Zebra Channel\nacestream://1111111111111111111111111111111111111111\n#EXTINF:-1 tvg-id=\"e2\",Alpha Channel\nacestream://2222222222222222222222222222222222222222\n`\n\n\tneweraContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"n1\",Beta Channel\nacestream://3333333333333333333333333333333333333333\n#EXTINF:-1 tvg-id=\"n2\",Gamma Channel\nacestream://4444444444444444444444444444444444444444\n`\n\n\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n\tdefer elcanoServer.Close()\n\n\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n\tdefer neweraServer.Close()\n\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n\n\t\tif elcanoErr != nil && neweraErr != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\tvar mergedContent strings.Builder\n\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n\n\t\tif elcanoErr == nil {\n\t\t\telcanoStr := string(elcanoContentBytes)\n\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(elcanoStr)\n\t\t}\n\n\t\tif neweraErr == nil {\n\t\t\tneweraStr := string(neweraContentBytes)\n\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n\t\t\t}\n\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n\t\t\t\tmergedContent.WriteString(\"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(neweraStr)\n\t\t}\n\n\t\tmergedBytes := []byte(mergedContent.String())\n\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody := make([]byte, 8192)\n\tn, _ := resp.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Find positions of channel names\n\talphaPos := strings.Index(bodyStr, \"Alpha Channel\")\n\tbetaPos := strings.Index(bodyStr, \"Beta Channel\")\n\tgammaPos := strings.Index(bodyStr, \"Gamma Channel\")\n\tzebraPos := strings.Index(bodyStr, \"Zebra Channel\")\n\n\t// Verify alphabetical order\n\tif alphaPos == -1 || betaPos == -1 || gammaPos == -1 || zebraPos == -1 {\n\t\tt.Fatal(\"Not all channels found in response\")\n\t}\n\n\tif !(alphaPos < betaPos && betaPos < gammaPos && gammaPos < zebraPos) {\n\t\tt.Errorf(\"Channels not in alphabetical order. Positions: Alpha=%d, Beta=%d, Gamma=%d, Zebra=%d\",\n\t\t\talphaPos, betaPos, gammaPos, zebraPos)\n\t}\n}\n\n// TestIntegration_UnifiedPlaylist_LogoRemoval tests that tvg-logo attributes are removed\nfunc TestIntegration_UnifiedPlaylist_LogoRemoval(t *testing.T) {\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\telcanoContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"e1\" tvg-logo=\"http://example.com/logo1.png\" tvg-name=\"Channel One\",Channel One\nacestream://1111111111111111111111111111111111111111\n`\n\n\tneweraContent := `#EXTM3U\n#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"Channel Two\" tvg-logo=\"http://example.com/logo2.png\",Channel Two\nacestream://2222222222222222222222222222222222222222\n`\n\n\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n\tdefer elcanoServer.Close()\n\n\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n\tdefer neweraServer.Close()\n\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n\n\t\tif elcanoErr != nil && neweraErr != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\tvar mergedContent strings.Builder\n\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n\n\t\tif elcanoErr == nil {\n\t\t\telcanoStr := string(elcanoContentBytes)\n\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(elcanoStr)\n\t\t}\n\n\t\tif neweraErr == nil {\n\t\t\tneweraStr := string(neweraContentBytes)\n\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n\t\t\t}\n\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n\t\t\t\tmergedContent.WriteString(\"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(neweraStr)\n\t\t}\n\n\t\tmergedBytes := []byte(mergedContent.String())\n\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody := make([]byte, 8192)\n\tn, _ := resp.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify logos are removed\n\tif strings.Contains(bodyStr, \"tvg-logo=\") {\n\t\tt.Error(\"Expected tvg-logo attributes to be removed\")\n\t}\n\tif strings.Contains(bodyStr, \"logo1.png\") {\n\t\tt.Error(\"Expected logo1.png to be removed\")\n\t}\n\tif strings.Contains(bodyStr, \"logo2.png\") {\n\t\tt.Error(\"Expected logo2.png to be removed\")\n\t}\n\n\t// Verify other metadata is preserved\n\tif !strings.Contains(bodyStr, \"tvg-id=\\\"e1\\\"\") {\n\t\tt.Error(\"Expected tvg-id to be preserved\")\n\t}\n\tif !strings.Contains(bodyStr, \"tvg-name=\\\"Channel One\\\"\") {\n\t\tt.Error(\"Expected tvg-name to be preserved\")\n\t}\n}\n\n// TestIntegration_UnifiedPlaylist_NetworkCachingParameter tests network-caching parameter in URLs\nfunc TestIntegration_UnifiedPlaylist_NetworkCachingParameter(t *testing.T) {\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\telcanoContent := `#EXTM3U\n#EXTINF:-1,Test Channel\nacestream://1111111111111111111111111111111111111111\n`\n\n\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n\tdefer elcanoServer.Close()\n\n\tneweraServer := createMockIPFSServer(t, true, \"\") // Failing server\n\tdefer neweraServer.Close()\n\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n\t\t_, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n\n\t\tif elcanoErr != nil && neweraErr != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\tvar mergedContent strings.Builder\n\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n\n\t\tif elcanoErr == nil {\n\t\t\telcanoStr := string(elcanoContentBytes)\n\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(elcanoStr)\n\t\t}\n\n\t\tmergedBytes := []byte(mergedContent.String())\n\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tbody := make([]byte, 8192)\n\tn, _ := resp.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify network-caching parameter is present\n\tif !strings.Contains(bodyStr, \"network-caching=1000\") {\n\t\tt.Error(\"Expected network-caching=1000 parameter in rewritten acestream URLs\")\n\t}\n\n\t// Verify complete URL format\n\texpectedURL := \"http://127.0.0.1:6878/ace/getstream?id=1111111111111111111111111111111111111111&network-caching=1000\"\n\tif !strings.Contains(bodyStr, expectedURL) {\n\t\tt.Errorf(\"Expected URL with network-caching parameter: %s\", expectedURL)\n\t}\n}\n\n// TestIntegration_UnifiedPlaylist_CacheFallback tests cache fallback when sources fail\nfunc TestIntegration_UnifiedPlaylist_CacheFallback(t *testing.T) {\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\telcanoContent := `#EXTM3U\n#EXTINF:-1,Cached Channel\nacestream://1111111111111111111111111111111111111111\n`\n\n\telcanoAvailable := true\n\telcanoServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif !elcanoAvailable {\n\t\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(elcanoContent))\n\t}))\n\tdefer elcanoServer.Close()\n\n\tneweraServer := createMockIPFSServer(t, true, \"\") // Always failing\n\tdefer neweraServer.Close()\n\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 100*time.Millisecond) // Short TTL\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n\t\t_, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n\n\t\tif elcanoErr != nil && neweraErr != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\tvar mergedContent strings.Builder\n\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n\n\t\tif elcanoErr == nil {\n\t\t\telcanoStr := string(elcanoContentBytes)\n\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n\t\t\t}\n\t\t\tmergedContent.WriteString(elcanoStr)\n\t\t}\n\n\t\tmergedBytes := []byte(mergedContent.String())\n\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// First request - populate cache\n\tresp1, err := http.Get(testServer.URL + \"/playlist.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make first request: %v\", err)\n\t}\n\tresp1.Body.Close()\n\n\tif resp1.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"Expected status code %d for first request, got %d\", http.StatusOK, resp1.StatusCode)\n\t}\n\n\t// Wait for cache to expire\n\ttime.Sleep(150 * time.Millisecond)\n\n\t// Make elcano unavailable\n\telcanoAvailable = false\n\n\t// Second request - should serve stale cache\n\tresp2, err := http.Get(testServer.URL + \"/playlist.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make second request: %v\", err)\n\t}\n\tdefer resp2.Body.Close()\n\n\tif resp2.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"Expected status code %d when serving stale cache, got %d\", http.StatusOK, resp2.StatusCode)\n\t}\n\n\tbody := make([]byte, 8192)\n\tn, _ := resp2.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify stale cache content is served\n\tif !strings.Contains(bodyStr, \"Cached Channel\") {\n\t\tt.Error(\"Expected stale cache content to be served\")\n\t}\n}","originalFile":"package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alorle/iptv-manager/cache\"\n\t\"github.com/alorle/iptv-manager/fetcher\"\n\t\"github.com/alorle/iptv-manager/rewriter\"\n)\n\nconst (\n\tmockM3UContent = `#EXTM3U\n#EXTINF:-1 tvg-id=\"test1\" tvg-name=\"Test Channel 1\" tvg-logo=\"http://example.com/logo1.png\" group-title=\"Sports\",Test Channel 1\nacestream://0000111122223333444455556666777788889999\n#EXTINF:-1 tvg-id=\"test2\" tvg-name=\"Test Channel 2\" group-title=\"Movies\",Test Channel 2\nhttp://example.com/stream.m3u8\n#EXTINF:-1 tvg-id=\"test3\" tvg-name=\"Test Channel 3\",Test Channel 3\nacestream://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n`\n)\n\n// setupTestEnvironment creates a temporary directory and returns cleanup function\nfunc setupTestEnvironment(t *testing.T) (string, func()) {\n\tt.Helper()\n\ttempDir := t.TempDir()\n\treturn tempDir, func() {}\n}\n\n// createMockIPFSServer creates an HTTP server that simulates IPFS behavior\nfunc createMockIPFSServer(t *testing.T, shouldFail bool, content string) *httptest.Server {\n\tt.Helper()\n\treturn httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif shouldFail {\n\t\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\t\tw.Write([]byte(\"IPFS node unavailable\"))\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(content))\n\t}))\n}\n\n// TestIntegration_FreshFetchFromMockIPFS tests fetching fresh content from mock IPFS server\nfunc TestIntegration_FreshFetchFromMockIPFS(t *testing.T) {\n\t// Setup test environment\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\t// Create mock IPFS server\n\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n\tdefer mockServer.Close()\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t// Create test server\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, fromCache, stale, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\tif fromCache {\n\t\t\tt.Error(\"Expected fresh fetch, but got cached content\")\n\t\t}\n\t\tif stale {\n\t\t\tt.Error(\"Expected fresh content, but got stale cache\")\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Make request\n\tresp, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\t// Verify HTTP status code\n\tif resp.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t}\n\n\t// Verify Content-Type header\n\tcontentType := resp.Header.Get(\"Content-Type\")\n\tif contentType != \"audio/x-mpegurl\" {\n\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t}\n\n\t// Read and verify response body\n\tbody := make([]byte, 4096)\n\tn, _ := resp.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify URL rewriting occurred\n\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=0000111122223333444455556666777788889999\") {\n\t\tt.Error(\"Expected first acestream URL to be rewritten\")\n\t}\n\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") {\n\t\tt.Error(\"Expected second acestream URL to be rewritten\")\n\t}\n\tif !strings.Contains(bodyStr, \"http://example.com/stream.m3u8\") {\n\t\tt.Error(\"Expected HTTP URL to be preserved\")\n\t}\n\tif !strings.Contains(bodyStr, \"#EXTINF\") {\n\t\tt.Error(\"Expected metadata to be preserved\")\n\t}\n}\n\n// TestIntegration_CacheHit tests serving content from fresh cache\nfunc TestIntegration_CacheHit(t *testing.T) {\n\t// Setup test environment\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\trequestCount := 0\n\t// Create mock IPFS server that counts requests\n\tmockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\trequestCount++\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(mockM3UContent))\n\t}))\n\tdefer mockServer.Close()\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t// Create test server\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, fromCache, stale, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\n\t\t// Store cache status for verification\n\t\tw.Header().Set(\"X-From-Cache\", fmt.Sprintf(\"%v\", fromCache))\n\t\tw.Header().Set(\"X-Stale\", fmt.Sprintf(\"%v\", stale))\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// First request - should fetch from IPFS\n\tresp1, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make first request: %v\", err)\n\t}\n\tresp1.Body.Close()\n\n\tif requestCount != 1 {\n\t\tt.Errorf(\"Expected 1 IPFS request after first fetch, got %d\", requestCount)\n\t}\n\n\t// Second request - should serve from cache\n\tresp2, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make second request: %v\", err)\n\t}\n\tdefer resp2.Body.Close()\n\n\t// Verify no additional IPFS requests were made\n\tif requestCount != 1 {\n\t\tt.Errorf(\"Expected 1 IPFS request after cache hit, got %d\", requestCount)\n\t}\n\n\t// Verify HTTP status code\n\tif resp2.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp2.StatusCode)\n\t}\n\n\t// Verify Content-Type header\n\tcontentType := resp2.Header.Get(\"Content-Type\")\n\tif contentType != \"audio/x-mpegurl\" {\n\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t}\n\n\t// Read response body\n\tbody := make([]byte, 4096)\n\tn, _ := resp2.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify URL rewriting still works\n\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=0000111122223333444455556666777788889999\") {\n\t\tt.Error(\"Expected acestream URL to be rewritten from cache\")\n\t}\n}\n\n// TestIntegration_ExpiredCacheRefresh tests cache refresh when TTL expires\nfunc TestIntegration_ExpiredCacheRefresh(t *testing.T) {\n\t// Setup test environment\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\trequestCount := 0\n\t// Create mock IPFS server\n\tmockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\trequestCount++\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\t// Send different content on second request\n\t\tif requestCount == 1 {\n\t\t\tw.Write([]byte(mockM3UContent))\n\t\t} else {\n\t\t\tw.Write([]byte(\"#EXTM3U\\n#EXTINF:-1,Updated Channel\\nacestream://bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"))\n\t\t}\n\t}))\n\tdefer mockServer.Close()\n\n\t// Initialize components with very short TTL\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 100*time.Millisecond) // 100ms TTL\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t// Create test server\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// First request - should fetch from IPFS\n\tresp1, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make first request: %v\", err)\n\t}\n\tbody1 := make([]byte, 4096)\n\tn1, _ := resp1.Body.Read(body1)\n\tresp1.Body.Close()\n\n\tif requestCount != 1 {\n\t\tt.Errorf(\"Expected 1 IPFS request, got %d\", requestCount)\n\t}\n\n\t// Wait for cache to expire\n\ttime.Sleep(150 * time.Millisecond)\n\n\t// Second request - should refresh cache\n\tresp2, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make second request: %v\", err)\n\t}\n\tbody2 := make([]byte, 4096)\n\tn2, _ := resp2.Body.Read(body2)\n\tresp2.Body.Close()\n\n\tif requestCount != 2 {\n\t\tt.Errorf(\"Expected 2 IPFS requests after cache expiration, got %d\", requestCount)\n\t}\n\n\t// Verify HTTP status code\n\tif resp2.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp2.StatusCode)\n\t}\n\n\t// Verify Content-Type header\n\tcontentType := resp2.Header.Get(\"Content-Type\")\n\tif contentType != \"audio/x-mpegurl\" {\n\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t}\n\n\t// Verify content changed (cache was refreshed)\n\tbodyStr1 := string(body1[:n1])\n\tbodyStr2 := string(body2[:n2])\n\n\tif !strings.Contains(bodyStr2, \"Updated Channel\") {\n\t\tt.Error(\"Expected refreshed content with 'Updated Channel'\")\n\t}\n\tif !strings.Contains(bodyStr2, \"http://127.0.0.1:6878/ace/getstream?id=bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\") {\n\t\tt.Error(\"Expected refreshed content with rewritten URL\")\n\t}\n\tif bodyStr1 == bodyStr2 {\n\t\tt.Error(\"Expected different content after cache refresh\")\n\t}\n}\n\n// TestIntegration_IPFSFailureWithStaleCacheFallback tests serving stale cache when IPFS fails\nfunc TestIntegration_IPFSFailureWithStaleCacheFallback(t *testing.T) {\n\t// Setup test environment\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\tipfsAvailable := true\n\t// Create mock IPFS server that can be toggled\n\tmockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif !ipfsAvailable {\n\t\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\t\tw.Write([]byte(\"IPFS node unavailable\"))\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(mockM3UContent))\n\t}))\n\tdefer mockServer.Close()\n\n\t// Initialize components with short TTL\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 100*time.Millisecond)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t// Create test server\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcontent, fromCache, stale, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.Header().Set(\"X-From-Cache\", fmt.Sprintf(\"%v\", fromCache))\n\t\tw.Header().Set(\"X-Stale\", fmt.Sprintf(\"%v\", stale))\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// First request - populate cache\n\tresp1, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make first request: %v\", err)\n\t}\n\tresp1.Body.Close()\n\n\t// Wait for cache to expire\n\ttime.Sleep(150 * time.Millisecond)\n\n\t// Make IPFS unavailable\n\tipfsAvailable = false\n\n\t// Second request - should serve stale cache\n\tresp2, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make second request: %v\", err)\n\t}\n\tdefer resp2.Body.Close()\n\n\t// Verify HTTP status code (should still be OK)\n\tif resp2.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp2.StatusCode)\n\t}\n\n\t// Verify Content-Type header\n\tcontentType := resp2.Header.Get(\"Content-Type\")\n\tif contentType != \"audio/x-mpegurl\" {\n\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t}\n\n\t// Read response body\n\tbody := make([]byte, 4096)\n\tn, _ := resp2.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify we got stale cache content (original content should be present)\n\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=0000111122223333444455556666777788889999\") {\n\t\tt.Error(\"Expected stale cache content with rewritten URL\")\n\t}\n\tif !strings.Contains(bodyStr, \"Test Channel 1\") {\n\t\tt.Error(\"Expected stale cache content with original metadata\")\n\t}\n}\n\n// TestIntegration_URLRewritingOutput tests that URL rewriting produces correct output\nfunc TestIntegration_URLRewritingOutput(t *testing.T) {\n\t// Setup test environment\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\t// Create mock IPFS server\n\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n\tdefer mockServer.Close()\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t// Create test server\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Make request\n\tresp, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\t// Read response body\n\tbody := make([]byte, 4096)\n\tn, _ := resp.Body.Read(body)\n\tbodyStr := string(body[:n])\n\n\t// Verify all acestream URLs are rewritten correctly\n\texpectedRewrites := []struct {\n\t\toriginal  string\n\t\trewritten string\n\t}{\n\t\t{\n\t\t\toriginal:  \"acestream://0000111122223333444455556666777788889999\",\n\t\t\trewritten: \"http://127.0.0.1:6878/ace/getstream?id=0000111122223333444455556666777788889999\",\n\t\t},\n\t\t{\n\t\t\toriginal:  \"acestream://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t\t\trewritten: \"http://127.0.0.1:6878/ace/getstream?id=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t\t},\n\t}\n\n\tfor _, test := range expectedRewrites {\n\t\tif strings.Contains(bodyStr, test.original) {\n\t\t\tt.Errorf(\"Expected original URL '%s' to be rewritten\", test.original)\n\t\t}\n\t\tif !strings.Contains(bodyStr, test.rewritten) {\n\t\t\tt.Errorf(\"Expected rewritten URL '%s' to be present\", test.rewritten)\n\t\t}\n\t}\n\n\t// Verify HTTP URLs are preserved\n\tif !strings.Contains(bodyStr, \"http://example.com/stream.m3u8\") {\n\t\tt.Error(\"Expected HTTP URL to be preserved unchanged\")\n\t}\n\n\t// Verify metadata is preserved (except logos which should be removed)\n\tmetadataChecks := []string{\n\t\t\"#EXTM3U\",\n\t\t\"#EXTINF:-1 tvg-id=\\\"test1\\\"\",\n\t\t\"tvg-name=\\\"Test Channel 1\\\"\",\n\t\t\"group-title=\\\"Sports\\\"\",\n\t\t\"Test Channel 1\",\n\t}\n\n\tfor _, check := range metadataChecks {\n\t\tif !strings.Contains(bodyStr, check) {\n\t\t\tt.Errorf(\"Expected metadata '%s' to be preserved\", check)\n\t\t}\n\t}\n\n\t// Verify logos are removed\n\tif strings.Contains(bodyStr, \"tvg-logo=\") {\n\t\tt.Error(\"Expected tvg-logo metadata to be removed\")\n\t}\n}\n\n// TestIntegration_ContentTypeHeaders tests that Content-Type headers are correct\nfunc TestIntegration_ContentTypeHeaders(t *testing.T) {\n\t// Setup test environment\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\t// Create mock IPFS server\n\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n\tdefer mockServer.Close()\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t// Create test server\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Make request\n\tresp, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\t// Verify Content-Type header\n\tcontentType := resp.Header.Get(\"Content-Type\")\n\texpectedContentType := \"audio/x-mpegurl\"\n\n\tif contentType != expectedContentType {\n\t\tt.Errorf(\"Expected Content-Type '%s', got '%s'\", expectedContentType, contentType)\n\t}\n\n\t// Verify Content-Type is present and not empty\n\tif contentType == \"\" {\n\t\tt.Error(\"Content-Type header is missing\")\n\t}\n}\n\n// TestIntegration_HTTPStatusCodes tests HTTP status codes for all scenarios\nfunc TestIntegration_HTTPStatusCodes(t *testing.T) {\n\ttests := []struct {\n\t\tname               string\n\t\tipfsFails          bool\n\t\tcacheExists        bool\n\t\texpectedStatusCode int\n\t\tdescription        string\n\t}{\n\t\t{\n\t\t\tname:               \"Success - Fresh fetch\",\n\t\t\tipfsFails:          false,\n\t\t\tcacheExists:        false,\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\tdescription:        \"Should return 200 OK when IPFS fetch succeeds\",\n\t\t},\n\t\t{\n\t\t\tname:               \"Success - Cache hit\",\n\t\t\tipfsFails:          false,\n\t\t\tcacheExists:        true,\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\tdescription:        \"Should return 200 OK when serving from cache\",\n\t\t},\n\t\t{\n\t\t\tname:               \"Success - Stale cache fallback\",\n\t\t\tipfsFails:          true,\n\t\t\tcacheExists:        true,\n\t\t\texpectedStatusCode: http.StatusOK,\n\t\t\tdescription:        \"Should return 200 OK when serving stale cache\",\n\t\t},\n\t\t{\n\t\t\tname:               \"Error - IPFS failure with no cache\",\n\t\t\tipfsFails:          true,\n\t\t\tcacheExists:        false,\n\t\t\texpectedStatusCode: http.StatusBadGateway,\n\t\t\tdescription:        \"Should return 502 Bad Gateway when IPFS fails and no cache exists\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Setup test environment\n\t\t\tcacheDir, cleanup := setupTestEnvironment(t)\n\t\t\tdefer cleanup()\n\n\t\t\t// Create mock IPFS server\n\t\t\tmockServer := createMockIPFSServer(t, tt.ipfsFails, mockM3UContent)\n\t\t\tdefer mockServer.Close()\n\n\t\t\t// Initialize components\n\t\t\tstorage, err := cache.NewFileStorage(cacheDir)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t\t\t}\n\n\t\t\t// Pre-populate cache if needed\n\t\t\tif tt.cacheExists {\n\t\t\t\tcacheKey := fmt.Sprintf(\"%s\", mockServer.URL)\n\t\t\t\tstorage.Set(cacheKey, []byte(mockM3UContent))\n\t\t\t}\n\n\t\t\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\t\t\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\t\t\t// Create test server\n\t\t\tmux := http.NewServeMux()\n\t\t\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\t\t\tif err != nil {\n\t\t\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\trewrittenContent := rw.RewriteM3U(content)\n\t\t\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\t\tw.Write(rewrittenContent)\n\t\t\t})\n\n\t\t\ttestServer := httptest.NewServer(mux)\n\t\t\tdefer testServer.Close()\n\n\t\t\t// Make request\n\t\t\tresp, err := http.Get(testServer.URL + \"/playlists/test.m3u\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to make request: %v\", err)\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\n\t\t\t// Verify status code\n\t\t\tif resp.StatusCode != tt.expectedStatusCode {\n\t\t\t\tt.Errorf(\"%s: Expected status code %d, got %d\", tt.description, tt.expectedStatusCode, resp.StatusCode)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestIntegration_MethodNotAllowed tests that non-GET methods return 405\nfunc TestIntegration_MethodNotAllowed(t *testing.T) {\n\t// Setup test environment\n\tcacheDir, cleanup := setupTestEnvironment(t)\n\tdefer cleanup()\n\n\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n\tdefer mockServer.Close()\n\n\tstorage, err := cache.NewFileStorage(cacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/playlists/test.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Test POST method\n\tresp, err := http.Post(testServer.URL+\"/playlists/test.m3u\", \"text/plain\", strings.NewReader(\"test\"))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to make POST request: %v\", err)\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusMethodNotAllowed {\n\t\tt.Errorf(\"Expected status code %d for POST, got %d\", http.StatusMethodNotAllowed, resp.StatusCode)\n\t}\n}\n\n// TestIntegration_RealEndpoints tests the actual elcano and newera endpoints\nfunc TestIntegration_RealEndpoints(t *testing.T) {\n\t// Setup test environment\n\tcacheDir := t.TempDir()\n\n\t// Set environment variables\n\tos.Setenv(\"CACHE_DIR\", cacheDir)\n\tos.Setenv(\"CACHE_TTL\", \"1h\")\n\tos.Setenv(\"HTTP_ADDRESS\", \"127.0.0.1\")\n\tos.Setenv(\"HTTP_PORT\", \"0\") // Use random port\n\tos.Setenv(\"ACESTREAM_PLAYER_BASE_URL\", \"http://127.0.0.1:6878/ace/getstream\")\n\n\tdefer func() {\n\t\tos.Unsetenv(\"CACHE_DIR\")\n\t\tos.Unsetenv(\"CACHE_TTL\")\n\t\tos.Unsetenv(\"HTTP_ADDRESS\")\n\t\tos.Unsetenv(\"HTTP_PORT\")\n\t\tos.Unsetenv(\"ACESTREAM_PLAYER_BASE_URL\")\n\t}()\n\n\t// Load configuration\n\tcfg, err := loadConfig()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to load config: %v\", err)\n\t}\n\n\t// Ensure cache directory is valid\n\tif !filepath.IsAbs(cfg.CacheDir) {\n\t\tt.Fatalf(\"Cache directory must be absolute path, got: %s\", cfg.CacheDir)\n\t}\n\n\t// Initialize components\n\tstorage, err := cache.NewFileStorage(cfg.CacheDir)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to initialize storage: %v\", err)\n\t}\n\n\tfetch := fetcher.New(30*time.Second, storage, cfg.CacheTTL)\n\trw := rewriter.New(cfg.AcestreamPlayerBaseURL)\n\n\t// Create mock IPFS server\n\tmockServer := createMockIPFSServer(t, false, mockM3UContent)\n\tdefer mockServer.Close()\n\n\t// Create test server with real endpoint handlers\n\tmux := http.NewServeMux()\n\n\t// Health endpoint\n\tmux.HandleFunc(\"/health\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\t// Elcano endpoint (modified to use mock server)\n\tmux.HandleFunc(\"/playlists/elcano.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\t// NewEra endpoint (modified to use mock server)\n\tmux.HandleFunc(\"/playlists/newera.m3u\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tcontent, _, _, err := fetch.FetchWithCache(mockServer.URL)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n\t\t\treturn\n\t\t}\n\n\t\trewrittenContent := rw.RewriteM3U(content)\n\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(rewrittenContent)\n\t})\n\n\ttestServer := httptest.NewServer(mux)\n\tdefer testServer.Close()\n\n\t// Test health endpoint\n\tt.Run(\"Health endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/health\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request health endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tbody := make([]byte, 10)\n\t\tn, _ := resp.Body.Read(body)\n\t\tif string(body[:n]) != \"OK\" {\n\t\t\tt.Errorf(\"Expected body 'OK', got '%s'\", string(body[:n]))\n\t\t}\n\t})\n\n\t// Test elcano endpoint\n\tt.Run(\"Elcano endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/playlists/elcano.m3u\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request elcano endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tcontentType := resp.Header.Get(\"Content-Type\")\n\t\tif contentType != \"audio/x-mpegurl\" {\n\t\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t\t}\n\n\t\tbody := make([]byte, 4096)\n\t\tn, _ := resp.Body.Read(body)\n\t\tbodyStr := string(body[:n])\n\n\t\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=\") {\n\t\t\tt.Error(\"Expected rewritten acestream URLs\")\n\t\t}\n\t})\n\n\t// Test newera endpoint\n\tt.Run(\"NewEra endpoint\", func(t *testing.T) {\n\t\tresp, err := http.Get(testServer.URL + \"/playlists/newera.m3u\")\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to request newera endpoint: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n\t\t}\n\n\t\tcontentType := resp.Header.Get(\"Content-Type\")\n\t\tif contentType != \"audio/x-mpegurl\" {\n\t\t\tt.Errorf(\"Expected Content-Type 'audio/x-mpegurl', got '%s'\", contentType)\n\t\t}\n\n\t\tbody := make([]byte, 4096)\n\t\tn, _ := resp.Body.Read(body)\n\t\tbodyStr := string(body[:n])\n\n\t\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=\") {\n\t\t\tt.Error(\"Expected rewritten acestream URLs\")\n\t\t}\n\t})\n}\n","structuredPatch":[{"oldStart":899,"oldLines":3,"newStart":899,"newLines":678,"lines":["     }","   })"," }","+","+// TestIntegration_UnifiedPlaylist_SuccessfulFetchAndMerge tests unified playlist endpoint","+// with successful fetch and merge from both sources","+func TestIntegration_UnifiedPlaylist_SuccessfulFetchAndMerge(t *testing.T) {","+  cacheDir, cleanup := setupTestEnvironment(t)","+  defer cleanup()","+","+  // Create mock content for elcano source","+  elcanoContent := `#EXTM3U","+#EXTINF:-1 tvg-id=\"e1\" tvg-name=\"Elcano One\" tvg-logo=\"http://example.com/logo1.png\" group-title=\"Sports\",Elcano One","+acestream://1111111111111111111111111111111111111111","+#EXTINF:-1 tvg-id=\"e2\" tvg-name=\"Elcano Two\",Elcano Two","+acestream://2222222222222222222222222222222222222222","+`","+","+  // Create mock content for newera source","+  neweraContent := `#EXTM3U","+#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"NewEra One\" tvg-logo=\"http://example.com/logo2.png\",NewEra One","+acestream://3333333333333333333333333333333333333333","+#EXTINF:-1 tvg-id=\"n2\" tvg-name=\"NewEra Two\",NewEra Two","+acestream://4444444444444444444444444444444444444444","+`","+","+  // Create mock servers","+  elcanoServer := createMockIPFSServer(t, false, elcanoContent)","+  defer elcanoServer.Close()","+","+  neweraServer := createMockIPFSServer(t, false, neweraContent)","+  defer neweraServer.Close()","+","+  // Initialize components","+  storage, err := cache.NewFileStorage(cacheDir)","+  if err != nil {","+    t.Fatalf(\"Failed to create storage: %v\", err)","+  }","+","+  fetch := fetcher.New(5*time.Second, storage, 1*time.Hour)","+  rw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")","+","+  // Create test server with unified endpoint","+  mux := http.NewServeMux()","+  mux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {","+    if r.Method != http.MethodGet {","+      http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)","+      return","+    }","+","+    // Fetch both sources","+    elcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)","+    neweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)","+","+    // Check if both sources failed","+    if elcanoErr != nil && neweraErr != nil {","+      http.Error(w, \"Bad Gateway\", http.StatusBadGateway)","+      return","+    }","+","+    // Build merged content","+    var mergedContent strings.Builder","+    mergedContent.WriteString(\"#EXTM3U\\n\")","+","+    if elcanoErr == nil {","+      elcanoStr := string(elcanoContentBytes)","+      if strings.HasPrefix(elcanoStr, \"#EXTM3U\") {","+        elcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")","+        elcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")","+      }","+      mergedContent.WriteString(elcanoStr)","+    }","+","+    if neweraErr == nil {","+      neweraStr := string(neweraContentBytes)","+      if strings.HasPrefix(neweraStr, \"#EXTM3U\") {","+        neweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")","+        neweraStr = strings.TrimLeft(neweraStr, \"\\n\")","+      }","+      if mergedContent.Len() > len(\"#EXTM3U\\n\") {","+        mergedContent.WriteString(\"\\n\")","+      }","+      mergedContent.WriteString(neweraStr)","+    }","+","+    // Apply deduplication, sorting, and rewriting","+    mergedBytes := []byte(mergedContent.String())","+    deduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)","+    sortedContent := rewriter.SortStreamsByName(deduplicatedContent)","+    rewrittenContent := rw.RewriteM3U(sortedContent)","+","+    w.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")","+    w.WriteHeader(http.StatusOK)","+    w.Write(rewrittenContent)","+  })","+","+  testServer := httptest.NewServer(mux)","+  defer testServer.Close()","+","+  // Make request","+  resp, err := http.Get(testServer.URL + \"/playlist.m3u\")","+  if err != nil {","+    t.Fatalf(\"Failed to make request: %v\", err)","+  }","+  defer resp.Body.Close()","+","+  if resp.StatusCode != http.StatusOK {","+    t.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)","+  }","+","+  body := make([]byte, 8192)","+  n, _ := resp.Body.Read(body)","+  bodyStr := string(body[:n])","+","+  // Verify all streams from both sources are present","+  if !strings.Contains(bodyStr, \"Elcano One\") {","+    t.Error(\"Expected 'Elcano One' from elcano source\")","+  }","+  if !strings.Contains(bodyStr, \"Elcano Two\") {","+    t.Error(\"Expected 'Elcano Two' from elcano source\")","+  }","+  if !strings.Contains(bodyStr, \"NewEra One\") {","+    t.Error(\"Expected 'NewEra One' from newera source\")","+  }","+  if !strings.Contains(bodyStr, \"NewEra Two\") {","+    t.Error(\"Expected 'NewEra Two' from newera source\")","+  }","+","+  // Verify URLs are rewritten","+  if !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=1111111111111111111111111111111111111111\") {","+    t.Error(\"Expected rewritten URL for stream 1\")","+  }","+  if !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=3333333333333333333333333333333333333333\") {","+    t.Error(\"Expected rewritten URL for stream 3\")","+  }","+}","+","+// TestIntegration_UnifiedPlaylist_Deduplication tests that duplicate streams are removed","+func TestIntegration_UnifiedPlaylist_Deduplication(t *testing.T) {","+  cacheDir, cleanup := setupTestEnvironment(t)","+  defer cleanup()","+","+  // Create mock content with duplicate acestream IDs","+  elcanoContent := `#EXTM3U","+#EXTINF:-1 tvg-id=\"e1\" tvg-name=\"Channel A\",Channel A","+acestream://1111111111111111111111111111111111111111","+#EXTINF:-1 tvg-id=\"e2\" tvg-name=\"Channel B\",Channel B","+acestream://2222222222222222222222222222222222222222","+`","+","+  neweraContent := `#EXTM3U","+#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"Channel A Duplicate\",Channel A Duplicate","+acestream://1111111111111111111111111111111111111111","+#EXTINF:-1 tvg-id=\"n2\" tvg-name=\"Channel C\",Channel C","+acestream://3333333333333333333333333333333333333333","+`","+","+  elcanoServer := createMockIPFSServer(t, false, elcanoContent)","+  defer elcanoServer.Close()","+","+  neweraServer := createMockIPFSServer(t, false, neweraContent)","+  defer neweraServer.Close()","+","+  storage, err := cache.NewFileStorage(cacheDir)","+  if err != nil {","+    t.Fatalf(\"Failed to create storage: %v\", err)","+  }","+","+  fetch := fetcher.New(5*time.Second, storage, 1*time.Hour)","+  rw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")","+","+  mux := http.NewServeMux()","+  mux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {","+    if r.Method != http.MethodGet {","+      http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)","+      return","+    }","+","+    elcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)","+    neweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)","+","+    if elcanoErr != nil && neweraErr != nil {","+      http.Error(w, \"Bad Gateway\", http.StatusBadGateway)","+      return","+    }","+","+    var mergedContent strings.Builder","+    mergedContent.WriteString(\"#EXTM3U\\n\")","+","+    if elcanoErr == nil {","+      elcanoStr := string(elcanoContentBytes)","+      if strings.HasPrefix(elcanoStr, \"#EXTM3U\") {","+        elcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")","+        elcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")","+      }","+      mergedContent.WriteString(elcanoStr)","+    }","+","+    if neweraErr == nil {","+      neweraStr := string(neweraContentBytes)","+      if strings.HasPrefix(neweraStr, \"#EXTM3U\") {","+        neweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")","+        neweraStr = strings.TrimLeft(neweraStr, \"\\n\")","+      }","+      if mergedContent.Len() > len(\"#EXTM3U\\n\") {","+        mergedContent.WriteString(\"\\n\")","+      }","+      mergedContent.WriteString(neweraStr)","+    }","+","+    mergedBytes := []byte(mergedContent.String())","+    deduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)","+    sortedContent := rewriter.SortStreamsByName(deduplicatedContent)","+    rewrittenContent := rw.RewriteM3U(sortedContent)","+","+    w.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")","+    w.WriteHeader(http.StatusOK)","+    w.Write(rewrittenContent)","+  })","+","+  testServer := httptest.NewServer(mux)","+  defer testServer.Close()","+","+  resp, err := http.Get(testServer.URL + \"/playlist.m3u\")","+  if err != nil {","+    t.Fatalf(\"Failed to make request: %v\", err)","+  }","+  defer resp.Body.Close()","+","+  body := make([]byte, 8192)","+  n, _ := resp.Body.Read(body)","+  bodyStr := string(body[:n])","+","+  // Count occurrences of the duplicate stream ID","+  duplicateCount := strings.Count(bodyStr, \"id=1111111111111111111111111111111111111111\")","+  if duplicateCount != 1 {","+    t.Errorf(\"Expected duplicate stream ID to appear once, but found %d occurrences\", duplicateCount)","+  }","+","+  // Verify first occurrence is kept","+  if !strings.Contains(bodyStr, \"Channel A\") {","+    t.Error(\"Expected first occurrence 'Channel A' to be preserved\")","+  }","+","+  // Verify duplicate is removed","+  if strings.Contains(bodyStr, \"Channel A Duplicate\") {","+    t.Error(\"Expected duplicate 'Channel A Duplicate' to be removed\")","+  }","+","+  // Verify other unique streams are present","+  if !strings.Contains(bodyStr, \"Channel B\") {","+    t.Error(\"Expected 'Channel B' to be present\")","+  }","+  if !strings.Contains(bodyStr, \"Channel C\") {","+    t.Error(\"Expected 'Channel C' to be present\")","+  }","+}","+","+// TestIntegration_UnifiedPlaylist_AlphabeticalSorting tests alphabetical sorting by display name","+func TestIntegration_UnifiedPlaylist_AlphabeticalSorting(t *testing.T) {","+  cacheDir, cleanup := setupTestEnvironment(t)","+  defer cleanup()","+","+  // Create mock content with unsorted names","+  elcanoContent := `#EXTM3U","+#EXTINF:-1 tvg-id=\"e1\",Zebra Channel","+acestream://1111111111111111111111111111111111111111","+#EXTINF:-1 tvg-id=\"e2\",Alpha Channel","+acestream://2222222222222222222222222222222222222222","+`","+","+  neweraContent := `#EXTM3U","+#EXTINF:-1 tvg-id=\"n1\",Beta Channel","+acestream://3333333333333333333333333333333333333333","+#EXTINF:-1 tvg-id=\"n2\",Gamma Channel","+acestream://4444444444444444444444444444444444444444","+`","+","+  elcanoServer := createMockIPFSServer(t, false, elcanoContent)","+  defer elcanoServer.Close()","+","+  neweraServer := createMockIPFSServer(t, false, neweraContent)","+  defer neweraServer.Close()","+","+  storage, err := cache.NewFileStorage(cacheDir)","+  if err != nil {","+    t.Fatalf(\"Failed to create storage: %v\", err)","+  }","+","+  fetch := fetcher.New(5*time.Second, storage, 1*time.Hour)","+  rw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")","+","+  mux := http.NewServeMux()","+  mux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {","+    if r.Method != http.MethodGet {","+      http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)","+      return","+    }","+","+    elcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)","+    neweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)","+","+    if elcanoErr != nil && neweraErr != nil {","+      http.Error(w, \"Bad Gateway\", http.StatusBadGateway)","+      return","+    }","+","+    var mergedContent strings.Builder","+    mergedContent.WriteString(\"#EXTM3U\\n\")","+","+    if elcanoErr == nil {","+      elcanoStr := string(elcanoContentBytes)","+      if strings.HasPrefix(elcanoStr, \"#EXTM3U\") {","+        elcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")","+        elcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")","+      }","+      mergedContent.WriteString(elcanoStr)","+    }","+","+    if neweraErr == nil {","+      neweraStr := string(neweraContentBytes)","+      if strings.HasPrefix(neweraStr, \"#EXTM3U\") {","+        neweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")","+        neweraStr = strings.TrimLeft(neweraStr, \"\\n\")","+      }","+      if mergedContent.Len() > len(\"#EXTM3U\\n\") {","+        mergedContent.WriteString(\"\\n\")","+      }","+      mergedContent.WriteString(neweraStr)","+    }","+","+    mergedBytes := []byte(mergedContent.String())","+    deduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)","+    sortedContent := rewriter.SortStreamsByName(deduplicatedContent)","+    rewrittenContent := rw.RewriteM3U(sortedContent)","+","+    w.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")","+    w.WriteHeader(http.StatusOK)","+    w.Write(rewrittenContent)","+  })","+","+  testServer := httptest.NewServer(mux)","+  defer testServer.Close()","+","+  resp, err := http.Get(testServer.URL + \"/playlist.m3u\")","+  if err != nil {","+    t.Fatalf(\"Failed to make request: %v\", err)","+  }","+  defer resp.Body.Close()","+","+  body := make([]byte, 8192)","+  n, _ := resp.Body.Read(body)","+  bodyStr := string(body[:n])","+","+  // Find positions of channel names","+  alphaPos := strings.Index(bodyStr, \"Alpha Channel\")","+  betaPos := strings.Index(bodyStr, \"Beta Channel\")","+  gammaPos := strings.Index(bodyStr, \"Gamma Channel\")","+  zebraPos := strings.Index(bodyStr, \"Zebra Channel\")","+","+  // Verify alphabetical order","+  if alphaPos == -1 || betaPos == -1 || gammaPos == -1 || zebraPos == -1 {","+    t.Fatal(\"Not all channels found in response\")","+  }","+","+  if !(alphaPos < betaPos && betaPos < gammaPos && gammaPos < zebraPos) {","+    t.Errorf(\"Channels not in alphabetical order. Positions: Alpha=%d, Beta=%d, Gamma=%d, Zebra=%d\",","+      alphaPos, betaPos, gammaPos, zebraPos)","+  }","+}","+","+// TestIntegration_UnifiedPlaylist_LogoRemoval tests that tvg-logo attributes are removed","+func TestIntegration_UnifiedPlaylist_LogoRemoval(t *testing.T) {","+  cacheDir, cleanup := setupTestEnvironment(t)","+  defer cleanup()","+","+  elcanoContent := `#EXTM3U","+#EXTINF:-1 tvg-id=\"e1\" tvg-logo=\"http://example.com/logo1.png\" tvg-name=\"Channel One\",Channel One","+acestream://1111111111111111111111111111111111111111","+`","+","+  neweraContent := `#EXTM3U","+#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"Channel Two\" tvg-logo=\"http://example.com/logo2.png\",Channel Two","+acestream://2222222222222222222222222222222222222222","+`","+","+  elcanoServer := createMockIPFSServer(t, false, elcanoContent)","+  defer elcanoServer.Close()","+","+  neweraServer := createMockIPFSServer(t, false, neweraContent)","+  defer neweraServer.Close()","+","+  storage, err := cache.NewFileStorage(cacheDir)","+  if err != nil {","+    t.Fatalf(\"Failed to create storage: %v\", err)","+  }","+","+  fetch := fetcher.New(5*time.Second, storage, 1*time.Hour)","+  rw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")","+","+  mux := http.NewServeMux()","+  mux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {","+    if r.Method != http.MethodGet {","+      http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)","+      return","+    }","+","+    elcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)","+    neweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)","+","+    if elcanoErr != nil && neweraErr != nil {","+      http.Error(w, \"Bad Gateway\", http.StatusBadGateway)","+      return","+    }","+","+    var mergedContent strings.Builder","+    mergedContent.WriteString(\"#EXTM3U\\n\")","+","+    if elcanoErr == nil {","+      elcanoStr := string(elcanoContentBytes)","+      if strings.HasPrefix(elcanoStr, \"#EXTM3U\") {","+        elcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")","+        elcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")","+      }","+      mergedContent.WriteString(elcanoStr)","+    }","+","+    if neweraErr == nil {","+      neweraStr := string(neweraContentBytes)","+      if strings.HasPrefix(neweraStr, \"#EXTM3U\") {","+        neweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")","+        neweraStr = strings.TrimLeft(neweraStr, \"\\n\")","+      }","+      if mergedContent.Len() > len(\"#EXTM3U\\n\") {","+        mergedContent.WriteString(\"\\n\")","+      }","+      mergedContent.WriteString(neweraStr)","+    }","+","+    mergedBytes := []byte(mergedContent.String())","+    deduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)","+    sortedContent := rewriter.SortStreamsByName(deduplicatedContent)","+    rewrittenContent := rw.RewriteM3U(sortedContent)","+","+    w.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")","+    w.WriteHeader(http.StatusOK)","+    w.Write(rewrittenContent)","+  })","+","+  testServer := httptest.NewServer(mux)","+  defer testServer.Close()","+","+  resp, err := http.Get(testServer.URL + \"/playlist.m3u\")","+  if err != nil {","+    t.Fatalf(\"Failed to make request: %v\", err)","+  }","+  defer resp.Body.Close()","+","+  body := make([]byte, 8192)","+  n, _ := resp.Body.Read(body)","+  bodyStr := string(body[:n])","+","+  // Verify logos are removed","+  if strings.Contains(bodyStr, \"tvg-logo=\") {","+    t.Error(\"Expected tvg-logo attributes to be removed\")","+  }","+  if strings.Contains(bodyStr, \"logo1.png\") {","+    t.Error(\"Expected logo1.png to be removed\")","+  }","+  if strings.Contains(bodyStr, \"logo2.png\") {","+    t.Error(\"Expected logo2.png to be removed\")","+  }","+","+  // Verify other metadata is preserved","+  if !strings.Contains(bodyStr, \"tvg-id=\\\"e1\\\"\") {","+    t.Error(\"Expected tvg-id to be preserved\")","+  }","+  if !strings.Contains(bodyStr, \"tvg-name=\\\"Channel One\\\"\") {","+    t.Error(\"Expected tvg-name to be preserved\")","+  }","+}","+","+// TestIntegration_UnifiedPlaylist_NetworkCachingParameter tests network-caching parameter in URLs","+func TestIntegration_UnifiedPlaylist_NetworkCachingParameter(t *testing.T) {","+  cacheDir, cleanup := setupTestEnvironment(t)","+  defer cleanup()","+","+  elcanoContent := `#EXTM3U","+#EXTINF:-1,Test Channel","+acestream://1111111111111111111111111111111111111111","+`","+","+  elcanoServer := createMockIPFSServer(t, false, elcanoContent)","+  defer elcanoServer.Close()","+","+  neweraServer := createMockIPFSServer(t, true, \"\") // Failing server","+  defer neweraServer.Close()","+","+  storage, err := cache.NewFileStorage(cacheDir)","+  if err != nil {","+    t.Fatalf(\"Failed to create storage: %v\", err)","+  }","+","+  fetch := fetcher.New(5*time.Second, storage, 1*time.Hour)","+  rw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")","+","+  mux := http.NewServeMux()","+  mux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {","+    if r.Method != http.MethodGet {","+      http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)","+      return","+    }","+","+    elcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)","+    _, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)","+","+    if elcanoErr != nil && neweraErr != nil {","+      http.Error(w, \"Bad Gateway\", http.StatusBadGateway)","+      return","+    }","+","+    var mergedContent strings.Builder","+    mergedContent.WriteString(\"#EXTM3U\\n\")","+","+    if elcanoErr == nil {","+      elcanoStr := string(elcanoContentBytes)","+      if strings.HasPrefix(elcanoStr, \"#EXTM3U\") {","+        elcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")","+        elcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")","+      }","+      mergedContent.WriteString(elcanoStr)","+    }","+","+    mergedBytes := []byte(mergedContent.String())","+    deduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)","+    sortedContent := rewriter.SortStreamsByName(deduplicatedContent)","+    rewrittenContent := rw.RewriteM3U(sortedContent)","+","+    w.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")","+    w.WriteHeader(http.StatusOK)","+    w.Write(rewrittenContent)","+  })","+","+  testServer := httptest.NewServer(mux)","+  defer testServer.Close()","+","+  resp, err := http.Get(testServer.URL + \"/playlist.m3u\")","+  if err != nil {","+    t.Fatalf(\"Failed to make request: %v\", err)","+  }","+  defer resp.Body.Close()","+","+  body := make([]byte, 8192)","+  n, _ := resp.Body.Read(body)","+  bodyStr := string(body[:n])","+","+  // Verify network-caching parameter is present","+  if !strings.Contains(bodyStr, \"network-caching=1000\") {","+    t.Error(\"Expected network-caching=1000 parameter in rewritten acestream URLs\")","+  }","+","+  // Verify complete URL format","+  expectedURL := \"http://127.0.0.1:6878/ace/getstream?id=1111111111111111111111111111111111111111&network-caching=1000\"","+  if !strings.Contains(bodyStr, expectedURL) {","+    t.Errorf(\"Expected URL with network-caching parameter: %s\", expectedURL)","+  }","+}","+","+// TestIntegration_UnifiedPlaylist_CacheFallback tests cache fallback when sources fail","+func TestIntegration_UnifiedPlaylist_CacheFallback(t *testing.T) {","+  cacheDir, cleanup := setupTestEnvironment(t)","+  defer cleanup()","+","+  elcanoContent := `#EXTM3U","+#EXTINF:-1,Cached Channel","+acestream://1111111111111111111111111111111111111111","+`","+","+  elcanoAvailable := true","+  elcanoServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {","+    if !elcanoAvailable {","+      w.WriteHeader(http.StatusServiceUnavailable)","+      return","+    }","+    w.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")","+    w.WriteHeader(http.StatusOK)","+    w.Write([]byte(elcanoContent))","+  }))","+  defer elcanoServer.Close()","+","+  neweraServer := createMockIPFSServer(t, true, \"\") // Always failing","+  defer neweraServer.Close()","+","+  storage, err := cache.NewFileStorage(cacheDir)","+  if err != nil {","+    t.Fatalf(\"Failed to create storage: %v\", err)","+  }","+","+  fetch := fetcher.New(5*time.Second, storage, 100*time.Millisecond) // Short TTL","+  rw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")","+","+  mux := http.NewServeMux()","+  mux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {","+    if r.Method != http.MethodGet {","+      http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)","+      return","+    }","+","+    elcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)","+    _, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)","+","+    if elcanoErr != nil && neweraErr != nil {","+      http.Error(w, \"Bad Gateway\", http.StatusBadGateway)","+      return","+    }","+","+    var mergedContent strings.Builder","+    mergedContent.WriteString(\"#EXTM3U\\n\")","+","+    if elcanoErr == nil {","+      elcanoStr := string(elcanoContentBytes)","+      if strings.HasPrefix(elcanoStr, \"#EXTM3U\") {","+        elcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")","+        elcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")","+      }","+      mergedContent.WriteString(elcanoStr)","+    }","+","+    mergedBytes := []byte(mergedContent.String())","+    deduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)","+    sortedContent := rewriter.SortStreamsByName(deduplicatedContent)","+    rewrittenContent := rw.RewriteM3U(sortedContent)","+","+    w.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")","+    w.WriteHeader(http.StatusOK)","+    w.Write(rewrittenContent)","+  })","+","+  testServer := httptest.NewServer(mux)","+  defer testServer.Close()","+","+  // First request - populate cache","+  resp1, err := http.Get(testServer.URL + \"/playlist.m3u\")","+  if err != nil {","+    t.Fatalf(\"Failed to make first request: %v\", err)","+  }","+  resp1.Body.Close()","+","+  if resp1.StatusCode != http.StatusOK {","+    t.Errorf(\"Expected status code %d for first request, got %d\", http.StatusOK, resp1.StatusCode)","+  }","+","+  // Wait for cache to expire","+  time.Sleep(150 * time.Millisecond)","+","+  // Make elcano unavailable","+  elcanoAvailable = false","+","+  // Second request - should serve stale cache","+  resp2, err := http.Get(testServer.URL + \"/playlist.m3u\")","+  if err != nil {","+    t.Fatalf(\"Failed to make second request: %v\", err)","+  }","+  defer resp2.Body.Close()","+","+  if resp2.StatusCode != http.StatusOK {","+    t.Errorf(\"Expected status code %d when serving stale cache, got %d\", http.StatusOK, resp2.StatusCode)","+  }","+","+  body := make([]byte, 8192)","+  n, _ := resp2.Body.Read(body)","+  bodyStr := string(body[:n])","+","+  // Verify stale cache content is served","+  if !strings.Contains(bodyStr, \"Cached Channel\") {","+    t.Error(\"Expected stale cache content to be served\")","+  }","+}"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01No59tUreUL5GrKCHJJqL6Z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GEds7VW5PstSkkZr7RM9a4","name":"TodoWrite","input":{"todos":[{"content":"Examine existing test patterns in main_test.go","activeForm":"Examining existing test patterns in main_test.go","status":"completed"},{"content":"Review the unified playlist endpoint implementation","activeForm":"Reviewing the unified playlist endpoint implementation","status":"completed"},{"content":"Write integration tests covering all acceptance criteria","activeForm":"Writing integration tests covering all acceptance criteria","status":"completed"},{"content":"Run go build ./... to verify build","activeForm":"Running go build ./... to verify build","status":"in_progress"},{"content":"Run go test ./... to verify all tests pass","activeForm":"Running go test ./... to verify all tests pass","status":"pending"},{"content":"Commit changes with feat message","activeForm":"Committing changes with feat message","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":11829,"cache_read_input_tokens":62040,"cache_creation":{"ephemeral_5m_input_tokens":11829,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"05d2b3d7-542a-454c-9e39-598ba56153f1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GEds7VW5PstSkkZr7RM9a4","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"3130e611-c402-466a-8fa3-a62c6f914670","tool_use_result":{"oldTodos":[{"content":"Examine existing test patterns in main_test.go","status":"completed","activeForm":"Examining existing test patterns in main_test.go"},{"content":"Review the unified playlist endpoint implementation","status":"completed","activeForm":"Reviewing the unified playlist endpoint implementation"},{"content":"Write integration tests covering all acceptance criteria","status":"in_progress","activeForm":"Writing integration tests covering all acceptance criteria"},{"content":"Run go build ./... to verify build","status":"pending","activeForm":"Running go build ./... to verify build"},{"content":"Run go test ./... to verify all tests pass","status":"pending","activeForm":"Running go test ./... to verify all tests pass"},{"content":"Commit changes with feat message","status":"pending","activeForm":"Committing changes with feat message"}],"newTodos":[{"content":"Examine existing test patterns in main_test.go","status":"completed","activeForm":"Examining existing test patterns in main_test.go"},{"content":"Review the unified playlist endpoint implementation","status":"completed","activeForm":"Reviewing the unified playlist endpoint implementation"},{"content":"Write integration tests covering all acceptance criteria","status":"completed","activeForm":"Writing integration tests covering all acceptance criteria"},{"content":"Run go build ./... to verify build","status":"in_progress","activeForm":"Running go build ./... to verify build"},{"content":"Run go test ./... to verify all tests pass","status":"pending","activeForm":"Running go test ./... to verify all tests pass"},{"content":"Commit changes with feat message","status":"pending","activeForm":"Committing changes with feat message"}]}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01YBsq69gtKNtzbgx3vNY7on","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AMfaRXdCBg1fkzU6sgiLc1","name":"Bash","input":{"command":"go build ./...","description":"Build the project to verify compilation"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":302,"cache_read_input_tokens":73869,"cache_creation":{"ephemeral_5m_input_tokens":302,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"4f5d37f7-662a-4a64-b4cd-93308d41d5eb"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AMfaRXdCBg1fkzU6sgiLc1","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"3e9cdaff-0d8d-4ad7-8c22-149c73ffad1a","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01QoG2MsxFrWK8Uywj78fMq1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CEfzqt51aLUQ6sV7ezAin7","name":"TodoWrite","input":{"todos":[{"content":"Examine existing test patterns in main_test.go","activeForm":"Examining existing test patterns in main_test.go","status":"completed"},{"content":"Review the unified playlist endpoint implementation","activeForm":"Reviewing the unified playlist endpoint implementation","status":"completed"},{"content":"Write integration tests covering all acceptance criteria","activeForm":"Writing integration tests covering all acceptance criteria","status":"completed"},{"content":"Run go build ./... to verify build","activeForm":"Running go build ./... to verify build","status":"completed"},{"content":"Run go test ./... to verify all tests pass","activeForm":"Running go test ./... to verify all tests pass","status":"in_progress"},{"content":"Commit changes with feat message","activeForm":"Committing changes with feat message","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":101,"cache_read_input_tokens":74171,"cache_creation":{"ephemeral_5m_input_tokens":101,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"1068061b-2459-4d7a-a818-9fabbb6b0c47"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CEfzqt51aLUQ6sV7ezAin7","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"68fb1fbe-4a83-43de-90d1-9aee744471de","tool_use_result":{"oldTodos":[{"content":"Examine existing test patterns in main_test.go","status":"completed","activeForm":"Examining existing test patterns in main_test.go"},{"content":"Review the unified playlist endpoint implementation","status":"completed","activeForm":"Reviewing the unified playlist endpoint implementation"},{"content":"Write integration tests covering all acceptance criteria","status":"completed","activeForm":"Writing integration tests covering all acceptance criteria"},{"content":"Run go build ./... to verify build","status":"in_progress","activeForm":"Running go build ./... to verify build"},{"content":"Run go test ./... to verify all tests pass","status":"pending","activeForm":"Running go test ./... to verify all tests pass"},{"content":"Commit changes with feat message","status":"pending","activeForm":"Committing changes with feat message"}],"newTodos":[{"content":"Examine existing test patterns in main_test.go","status":"completed","activeForm":"Examining existing test patterns in main_test.go"},{"content":"Review the unified playlist endpoint implementation","status":"completed","activeForm":"Reviewing the unified playlist endpoint implementation"},{"content":"Write integration tests covering all acceptance criteria","status":"completed","activeForm":"Writing integration tests covering all acceptance criteria"},{"content":"Run go build ./... to verify build","status":"completed","activeForm":"Running go build ./... to verify build"},{"content":"Run go test ./... to verify all tests pass","status":"in_progress","activeForm":"Running go test ./... to verify all tests pass"},{"content":"Commit changes with feat message","status":"pending","activeForm":"Committing changes with feat message"}]}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013Ujewam3YakxSjfX4bgEso","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BBDNDpJM7KRZy9fU19ovZc","name":"Bash","input":{"command":"go test ./...","description":"Run all tests to verify they pass","timeout":60000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":303,"cache_read_input_tokens":74272,"cache_creation":{"ephemeral_5m_input_tokens":303,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"11ee2c3b-fc36-4365-91a4-3d1e8f887f2e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BBDNDpJM7KRZy9fU19ovZc","type":"tool_result","content":"ok  \tgithub.com/alorle/iptv-manager\t0.501s\nok  \tgithub.com/alorle/iptv-manager/cache\t(cached)\nok  \tgithub.com/alorle/iptv-manager/fetcher\t(cached)\nok  \tgithub.com/alorle/iptv-manager/rewriter\t(cached)","is_error":false}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"3b048c72-7e6a-4d68-8a75-71e948e011e7","tool_use_result":{"stdout":"ok  \tgithub.com/alorle/iptv-manager\t0.501s\nok  \tgithub.com/alorle/iptv-manager/cache\t(cached)\nok  \tgithub.com/alorle/iptv-manager/fetcher\t(cached)\nok  \tgithub.com/alorle/iptv-manager/rewriter\t(cached)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012TsGSX8NvfTreeeyvRGfFr","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! All tests pass. Now let me commit the changes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":199,"cache_read_input_tokens":74575,"cache_creation":{"ephemeral_5m_input_tokens":199,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"0b65db4c-f9e5-482b-930f-077b0515037f"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012TsGSX8NvfTreeeyvRGfFr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018XUr6Ly9yQsNNzPUWqnJ4n","name":"TodoWrite","input":{"todos":[{"content":"Examine existing test patterns in main_test.go","activeForm":"Examining existing test patterns in main_test.go","status":"completed"},{"content":"Review the unified playlist endpoint implementation","activeForm":"Reviewing the unified playlist endpoint implementation","status":"completed"},{"content":"Write integration tests covering all acceptance criteria","activeForm":"Writing integration tests covering all acceptance criteria","status":"completed"},{"content":"Run go build ./... to verify build","activeForm":"Running go build ./... to verify build","status":"completed"},{"content":"Run go test ./... to verify all tests pass","activeForm":"Running go test ./... to verify all tests pass","status":"completed"},{"content":"Commit changes with feat message","activeForm":"Committing changes with feat message","status":"in_progress"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":199,"cache_read_input_tokens":74575,"cache_creation":{"ephemeral_5m_input_tokens":199,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"eab9cafd-8759-41c2-8332-9a1d9a84901b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018XUr6Ly9yQsNNzPUWqnJ4n","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"c0a2dd16-de21-4d7a-b407-e98c91d968bc","tool_use_result":{"oldTodos":[{"content":"Examine existing test patterns in main_test.go","status":"completed","activeForm":"Examining existing test patterns in main_test.go"},{"content":"Review the unified playlist endpoint implementation","status":"completed","activeForm":"Reviewing the unified playlist endpoint implementation"},{"content":"Write integration tests covering all acceptance criteria","status":"completed","activeForm":"Writing integration tests covering all acceptance criteria"},{"content":"Run go build ./... to verify build","status":"completed","activeForm":"Running go build ./... to verify build"},{"content":"Run go test ./... to verify all tests pass","status":"in_progress","activeForm":"Running go test ./... to verify all tests pass"},{"content":"Commit changes with feat message","status":"pending","activeForm":"Committing changes with feat message"}],"newTodos":[{"content":"Examine existing test patterns in main_test.go","status":"completed","activeForm":"Examining existing test patterns in main_test.go"},{"content":"Review the unified playlist endpoint implementation","status":"completed","activeForm":"Reviewing the unified playlist endpoint implementation"},{"content":"Write integration tests covering all acceptance criteria","status":"completed","activeForm":"Writing integration tests covering all acceptance criteria"},{"content":"Run go build ./... to verify build","status":"completed","activeForm":"Running go build ./... to verify build"},{"content":"Run go test ./... to verify all tests pass","status":"completed","activeForm":"Running go test ./... to verify all tests pass"},{"content":"Commit changes with feat message","status":"in_progress","activeForm":"Committing changes with feat message"}]}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01T8qucJtZJcNCiyr15HFSa9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018CuQqi1fgQ7tmCfVMgF3JJ","name":"Bash","input":{"command":"git status","description":"Check git status"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":316,"cache_read_input_tokens":74774,"cache_creation":{"ephemeral_5m_input_tokens":316,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"5da7ea98-ef8d-4f3e-a78e-5ca0af77ed23"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018CuQqi1fgQ7tmCfVMgF3JJ","type":"tool_result","content":"On branch main\nYour branch is ahead of 'origin/main' by 12 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .ralph-tui/session-meta.json\n\tmodified:   .ralph-tui/session.json\n\tmodified:   main_test.go\n\tmodified:   tasks/prd.json\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.ralph-tui/iterations/a04ca31d_2026-01-31_12-57-46_US-002.log\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"e7b83651-3afc-48c8-85e8-e466d877ae98","tool_use_result":{"stdout":"On branch main\nYour branch is ahead of 'origin/main' by 12 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .ralph-tui/session-meta.json\n\tmodified:   .ralph-tui/session.json\n\tmodified:   main_test.go\n\tmodified:   tasks/prd.json\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.ralph-tui/iterations/a04ca31d_2026-01-31_12-57-46_US-002.log\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01T8qucJtZJcNCiyr15HFSa9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013EbNFEWUKKGbMdKJAkDaA1","name":"Bash","input":{"command":"git diff main_test.go","description":"Show diff for main_test.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":316,"cache_read_input_tokens":74774,"cache_creation":{"ephemeral_5m_input_tokens":316,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"b5cd4f96-38cb-4ee4-a11f-aec7030cb844"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013EbNFEWUKKGbMdKJAkDaA1","type":"tool_result","content":"diff --git a/main_test.go b/main_test.go\nindex 8c682f5..99c9cc6 100644\n--- a/main_test.go\n+++ b/main_test.go\n@@ -899,3 +899,678 @@ func TestIntegration_RealEndpoints(t *testing.T) {\n \t\t}\n \t})\n }\n+\n+// TestIntegration_UnifiedPlaylist_SuccessfulFetchAndMerge tests unified playlist endpoint\n+// with successful fetch and merge from both sources\n+func TestIntegration_UnifiedPlaylist_SuccessfulFetchAndMerge(t *testing.T) {\n+\tcacheDir, cleanup := setupTestEnvironment(t)\n+\tdefer cleanup()\n+\n+\t// Create mock content for elcano source\n+\telcanoContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"e1\" tvg-name=\"Elcano One\" tvg-logo=\"http://example.com/logo1.png\" group-title=\"Sports\",Elcano One\n+acestream://1111111111111111111111111111111111111111\n+#EXTINF:-1 tvg-id=\"e2\" tvg-name=\"Elcano Two\",Elcano Two\n+acestream://2222222222222222222222222222222222222222\n+`\n+\n+\t// Create mock content for newera source\n+\tneweraContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"NewEra One\" tvg-logo=\"http://example.com/logo2.png\",NewEra One\n+acestream://3333333333333333333333333333333333333333\n+#EXTINF:-1 tvg-id=\"n2\" tvg-name=\"NewEra Two\",NewEra Two\n+acestream://4444444444444444444444444444444444444444\n+`\n+\n+\t// Create mock servers\n+\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n+\tdefer elcanoServer.Close()\n+\n+\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n+\tdefer neweraServer.Close()\n+\n+\t// Initialize components\n+\tstorage, err := cache.NewFileStorage(cacheDir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n+\t}\n+\n+\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n+\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n+\n+\t// Create test server with unified endpoint\n+\tmux := http.NewServeMux()\n+\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n+\t\tif r.Method != http.MethodGet {\n+\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Fetch both sources\n+\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n+\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n+\n+\t\t// Check if both sources failed\n+\t\tif elcanoErr != nil && neweraErr != nil {\n+\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Build merged content\n+\t\tvar mergedContent strings.Builder\n+\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n+\n+\t\tif elcanoErr == nil {\n+\t\t\telcanoStr := string(elcanoContentBytes)\n+\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n+\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n+\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(elcanoStr)\n+\t\t}\n+\n+\t\tif neweraErr == nil {\n+\t\t\tneweraStr := string(neweraContentBytes)\n+\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n+\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n+\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n+\t\t\t}\n+\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n+\t\t\t\tmergedContent.WriteString(\"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(neweraStr)\n+\t\t}\n+\n+\t\t// Apply deduplication, sorting, and rewriting\n+\t\tmergedBytes := []byte(mergedContent.String())\n+\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n+\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n+\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write(rewrittenContent)\n+\t})\n+\n+\ttestServer := httptest.NewServer(mux)\n+\tdefer testServer.Close()\n+\n+\t// Make request\n+\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to make request: %v\", err)\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\tif resp.StatusCode != http.StatusOK {\n+\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n+\t}\n+\n+\tbody := make([]byte, 8192)\n+\tn, _ := resp.Body.Read(body)\n+\tbodyStr := string(body[:n])\n+\n+\t// Verify all streams from both sources are present\n+\tif !strings.Contains(bodyStr, \"Elcano One\") {\n+\t\tt.Error(\"Expected 'Elcano One' from elcano source\")\n+\t}\n+\tif !strings.Contains(bodyStr, \"Elcano Two\") {\n+\t\tt.Error(\"Expected 'Elcano Two' from elcano source\")\n+\t}\n+\tif !strings.Contains(bodyStr, \"NewEra One\") {\n+\t\tt.Error(\"Expected 'NewEra One' from newera source\")\n+\t}\n+\tif !strings.Contains(bodyStr, \"NewEra Two\") {\n+\t\tt.Error(\"Expected 'NewEra Two' from newera source\")\n+\t}\n+\n+\t// Verify URLs are rewritten\n+\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=1111111111111111111111111111111111111111\") {\n+\t\tt.Error(\"Expected rewritten URL for stream 1\")\n+\t}\n+\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=3333333333333333333333333333333333333333\") {\n+\t\tt.Error(\"Expected rewritten URL for stream 3\")\n+\t}\n+}\n+\n+// TestIntegration_UnifiedPlaylist_Deduplication tests that duplicate streams are removed\n+func TestIntegration_UnifiedPlaylist_Deduplication(t *testing.T) {\n+\tcacheDir, cleanup := setupTestEnvironment(t)\n+\tdefer cleanup()\n+\n+\t// Create mock content with duplicate acestream IDs\n+\telcanoContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"e1\" tvg-name=\"Channel A\",Channel A\n+acestream://1111111111111111111111111111111111111111\n+#EXTINF:-1 tvg-id=\"e2\" tvg-name=\"Channel B\",Channel B\n+acestream://2222222222222222222222222222222222222222\n+`\n+\n+\tneweraContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"Channel A Duplicate\",Channel A Duplicate\n+acestream://1111111111111111111111111111111111111111\n+#EXTINF:-1 tvg-id=\"n2\" tvg-name=\"Channel C\",Channel C\n+acestream://3333333333333333333333333333333333333333\n+`\n+\n+\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n+\tdefer elcanoServer.Close()\n+\n+\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n+\tdefer neweraServer.Close()\n+\n+\tstorage, err := cache.NewFileStorage(cacheDir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n+\t}\n+\n+\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n+\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n+\n+\tmux := http.NewServeMux()\n+\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n+\t\tif r.Method != http.MethodGet {\n+\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n+\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n+\n+\t\tif elcanoErr != nil && neweraErr != nil {\n+\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar mergedContent strings.Builder\n+\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n+\n+\t\tif elcanoErr == nil {\n+\t\t\telcanoStr := string(elcanoContentBytes)\n+\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n+\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n+\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(elcanoStr)\n+\t\t}\n+\n+\t\tif neweraErr == nil {\n+\t\t\tneweraStr := string(neweraContentBytes)\n+\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n+\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n+\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n+\t\t\t}\n+\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n+\t\t\t\tmergedContent.WriteString(\"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(neweraStr)\n+\t\t}\n+\n+\t\tmergedBytes := []byte(mergedContent.String())\n+\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n+\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n+\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write(rewrittenContent)\n+\t})\n+\n+\ttestServer := httptest.NewServer(mux)\n+\tdefer testServer.Close()\n+\n+\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to make request: %v\", err)\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\tbody := make([]byte, 8192)\n+\tn, _ := resp.Body.Read(body)\n+\tbodyStr := string(body[:n])\n+\n+\t// Count occurrences of the duplicate stream ID\n+\tduplicateCount := strings.Count(bodyStr, \"id=1111111111111111111111111111111111111111\")\n+\tif duplicateCount != 1 {\n+\t\tt.Errorf(\"Expected duplicate stream ID to appear once, but found %d occurrences\", duplicateCount)\n+\t}\n+\n+\t// Verify first occurrence is kept\n+\tif !strings.Contains(bodyStr, \"Channel A\") {\n+\t\tt.Error(\"Expected first occurrence 'Channel A' to be preserved\")\n+\t}\n+\n+\t// Verify duplicate is removed\n+\tif strings.Contains(bodyStr, \"Channel A Duplicate\") {\n+\t\tt.Error(\"Expected duplicate 'Channel A Duplicate' to be removed\")\n+\t}\n+\n+\t// Verify other unique streams are present\n+\tif !strings.Contains(bodyStr, \"Channel B\") {\n+\t\tt.Error(\"Expected 'Channel B' to be present\")\n+\t}\n+\tif !strings.Contains(bodyStr, \"Channel C\") {\n+\t\tt.Error(\"Expected 'Channel C' to be present\")\n+\t}\n+}\n+\n+// TestIntegration_UnifiedPlaylist_AlphabeticalSorting tests alphabetical sorting by display name\n+func TestIntegration_UnifiedPlaylist_AlphabeticalSorting(t *testing.T) {\n+\tcacheDir, cleanup := setupTestEnvironment(t)\n+\tdefer cleanup()\n+\n+\t// Create mock content with unsorted names\n+\telcanoContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"e1\",Zebra Channel\n+acestream://1111111111111111111111111111111111111111\n+#EXTINF:-1 tvg-id=\"e2\",Alpha Channel\n+acestream://2222222222222222222222222222222222222222\n+`\n+\n+\tneweraContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"n1\",Beta Channel\n+acestream://3333333333333333333333333333333333333333\n+#EXTINF:-1 tvg-id=\"n2\",Gamma Channel\n+acestream://4444444444444444444444444444444444444444\n+`\n+\n+\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n+\tdefer elcanoServer.Close()\n+\n+\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n+\tdefer neweraServer.Close()\n+\n+\tstorage, err := cache.NewFileStorage(cacheDir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n+\t}\n+\n+\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n+\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n+\n+\tmux := http.NewServeMux()\n+\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n+\t\tif r.Method != http.MethodGet {\n+\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n+\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n+\n+\t\tif elcanoErr != nil && neweraErr != nil {\n+\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar mergedContent strings.Builder\n+\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n+\n+\t\tif elcanoErr == nil {\n+\t\t\telcanoStr := string(elcanoContentBytes)\n+\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n+\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n+\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(elcanoStr)\n+\t\t}\n+\n+\t\tif neweraErr == nil {\n+\t\t\tneweraStr := string(neweraContentBytes)\n+\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n+\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n+\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n+\t\t\t}\n+\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n+\t\t\t\tmergedContent.WriteString(\"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(neweraStr)\n+\t\t}\n+\n+\t\tmergedBytes := []byte(mergedContent.String())\n+\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n+\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n+\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write(rewrittenContent)\n+\t})\n+\n+\ttestServer := httptest.NewServer(mux)\n+\tdefer testServer.Close()\n+\n+\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to make request: %v\", err)\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\tbody := make([]byte, 8192)\n+\tn, _ := resp.Body.Read(body)\n+\tbodyStr := string(body[:n])\n+\n+\t// Find positions of channel names\n+\talphaPos := strings.Index(bodyStr, \"Alpha Channel\")\n+\tbetaPos := strings.Index(bodyStr, \"Beta Channel\")\n+\tgammaPos := strings.Index(bodyStr, \"Gamma Channel\")\n+\tzebraPos := strings.Index(bodyStr, \"Zebra Channel\")\n+\n+\t// Verify alphabetical order\n+\tif alphaPos == -1 || betaPos == -1 || gammaPos == -1 || zebraPos == -1 {\n+\t\tt.Fatal(\"Not all channels found in response\")\n+\t}\n+\n+\tif !(alphaPos < betaPos && betaPos < gammaPos && gammaPos < zebraPos) {\n+\t\tt.Errorf(\"Channels not in alphabetical order. Positions: Alpha=%d, Beta=%d, Gamma=%d, Zebra=%d\",\n+\t\t\talphaPos, betaPos, gammaPos, zebraPos)\n+\t}\n+}\n+\n+// TestIntegration_UnifiedPlaylist_LogoRemoval tests that tvg-logo attributes are removed\n+func TestIntegration_UnifiedPlaylist_LogoRemoval(t *testing.T) {\n+\tcacheDir, cleanup := setupTestEnvironment(t)\n+\tdefer cleanup()\n+\n+\telcanoContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"e1\" tvg-logo=\"http://example.com/logo1.png\" tvg-name=\"Channel One\",Channel One\n+acestream://1111111111111111111111111111111111111111\n+`\n+\n+\tneweraContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"Channel Two\" tvg-logo=\"http://example.com/logo2.png\",Channel Two\n+acestream://2222222222222222222222222222222222222222\n+`\n+\n+\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n+\tdefer elcanoServer.Close()\n+\n+\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n+\tdefer neweraServer.Close()\n+\n+\tstorage, err := cache.NewFileStorage(cacheDir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n+\t}\n+\n+\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n+\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n+\n+\tmux := http.NewServeMux()\n+\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n+\t\tif r.Method != http.MethodGet {\n+\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n+\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n+\n+\t\tif elcanoErr != nil && neweraErr != nil {\n+\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar mergedContent strings.Builder\n+\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n+\n+\t\tif elcanoErr == nil {\n+\t\t\telcanoStr := string(elcanoContentBytes)\n+\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n+\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n+\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(elcanoStr)\n+\t\t}\n+\n+\t\tif neweraErr == nil {\n+\t\t\tneweraStr := string(neweraContentBytes)\n+\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n+\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n+\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n+\t\t\t}\n+\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n+\t\t\t\tmergedContent.WriteString(\"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(neweraStr)\n+\t\t}\n+\n+\t\tmergedBytes := []byte(mergedContent.String())\n+\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n+\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n+\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write(rewrittenContent)\n+\t})\n+\n+\ttestServer := httptest.NewServer(mux)\n+\tdefer testServer.Close()\n+\n+\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to make request: %v\", err)\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\tbody := make([]byte, 8192)\n+\tn, _ := resp.Body.Read(body)\n+\tbodyStr := string(body[:n])\n+\n+\t// Verify logos are removed\n+\tif strings.Contains(bodyStr, \"tvg-logo=\") {\n+\t\tt.Error(\"Expected tvg-logo attributes to be removed\")\n+\t}\n+\tif strings.Contains(bodyStr, \"logo1.png\") {\n+\t\tt.Error(\"Expected logo1.png to be removed\")\n+\t}\n+\tif strings.Contains(bodyStr, \"logo2.png\") {\n+\t\tt.Error(\"Expected logo2.png to be removed\")\n+\t}\n+\n+\t// Verify other metadata is preserved\n+\tif !strings.Contains(bodyStr, \"tvg-id=\\\"e1\\\"\") {\n+\t\tt.Error(\"Expected tvg-id to be preserved\")\n+\t}\n+\tif !strings.Contains(bodyStr, \"tvg-name=\\\"Channel One\\\"\") {\n+\t\tt.Error(\"Expected tvg-name to be preserved\")\n+\t}\n+}\n+\n+// TestIntegration_UnifiedPlaylist_NetworkCachingParameter tests network-caching parameter in URLs\n+func TestIntegration_UnifiedPlaylist_NetworkCachingParameter(t *testing.T) {\n+\tcacheDir, cleanup := setupTestEnvironment(t)\n+\tdefer cleanup()\n+\n+\telcanoContent := `#EXTM3U\n+#EXTINF:-1,Test Channel\n+acestream://1111111111111111111111111111111111111111\n+`\n+\n+\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n+\tdefer elcanoServer.Close()\n+\n+\tneweraServer := createMockIPFSServer(t, true, \"\") // Failing server\n+\tdefer neweraServer.Close()\n+\n+\tstorage, err := cache.NewFileStorage(cacheDir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n+\t}\n+\n+\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n+\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n+\n+\tmux := http.NewServeMux()\n+\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n+\t\tif r.Method != http.MethodGet {\n+\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n+\t\t_, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n+\n+\t\tif elcanoErr != nil && neweraErr != nil {\n+\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar mergedContent strings.Builder\n+\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n+\n+\t\tif elcanoErr == nil {\n+\t\t\telcanoStr := string(elcanoContentBytes)\n+\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n+\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n+\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(elcanoStr)\n+\t\t}\n+\n+\t\tmergedBytes := []byte(mergedContent.String())\n+\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n+\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n+\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write(rewrittenContent)\n+\t})\n+\n+\ttestServer := httptest.NewServer(mux)\n+\tdefer testServer.Close()\n+\n+\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to make request: %v\", err)\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\tbody := make([]byte, 8192)\n+\tn, _ := resp.Body.Read(body)\n+\tbodyStr := string(body[:n])\n+\n+\t// Verify network-caching parameter is present\n+\tif !strings.Contains(bodyStr, \"network-caching=1000\") {\n+\t\tt.Error(\"Expected network-caching=1000 parameter in rewritten acestream URLs\")\n+\t}\n+\n+\t// Verify complete URL format\n+\texpectedURL := \"http://127.0.0.1:6878/ace/getstream?id=1111111111111111111111111111111111111111&network-caching=1000\"\n+\tif !strings.Contains(bodyStr, expectedURL) {\n+\t\tt.Errorf(\"Expected URL with network-caching parameter: %s\", expectedURL)\n+\t}\n+}\n+\n+// TestIntegration_UnifiedPlaylist_CacheFallback tests cache fallback when sources fail\n+func TestIntegration_UnifiedPlaylist_CacheFallback(t *testing.T) {\n+\tcacheDir, cleanup := setupTestEnvironment(t)\n+\tdefer cleanup()\n+\n+\telcanoContent := `#EXTM3U\n+#EXTINF:-1,Cached Channel\n+acestream://1111111111111111111111111111111111111111\n+`\n+\n+\telcanoAvailable := true\n+\telcanoServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tif !elcanoAvailable {\n+\t\t\tw.WriteHeader(http.StatusServiceUnavailable)\n+\t\t\treturn\n+\t\t}\n+\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write([]byte(elcanoContent))\n+\t}))\n+\tdefer elcanoServer.Close()\n+\n+\tneweraServer := createMockIPFSServer(t, true, \"\") // Always failing\n+\tdefer neweraServer.Close()\n+\n+\tstorage, err := cache.NewFileStorage(cacheDir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n+\t}\n+\n+\tfetch := fetcher.New(5*time.Second, storage, 100*time.Millisecond) // Short TTL\n+\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n+\n+\tmux := http.NewServeMux()\n+\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n+\t\tif r.Method != http.MethodGet {\n+\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n+\t\t_, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n+\n+\t\tif elcanoErr != nil && neweraErr != nil {\n+\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar mergedContent strings.Builder\n+\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n+\n+\t\tif elcanoErr == nil {\n+\t\t\telcanoStr := string(elcanoContentBytes)\n+\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n+\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n+\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(elcanoStr)\n+\t\t}\n+\n+\t\tmergedBytes := []byte(mergedContent.String())\n+\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n+\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n+\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write(rewrittenContent)\n+\t})\n+\n+\ttestServer := httptest.NewServer(mux)\n+\tdefer testServer.Close()\n+\n+\t// First request - populate cache\n+\tresp1, err := http.Get(testServer.URL + \"/playlist.m3u\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to make first request: %v\", err)\n+\t}\n+\tresp1.Body.Close()\n+\n+\tif resp1.StatusCode != http.StatusOK {\n+\t\tt.Errorf(\"Expected status code %d for first request, got %d\", http.StatusOK, resp1.StatusCode)\n+\t}\n+\n+\t// Wait for cache to expire\n+\ttime.Sleep(150 * time.Millisecond)\n+\n+\t// Make elcano unavailable\n+\telcanoAvailable = false\n+\n+\t// Second request - should serve stale cache\n+\tresp2, err := http.Get(testServer.URL + \"/playlist.m3u\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to make second request: %v\", err)\n+\t}\n+\tdefer resp2.Body.Close()\n+\n+\tif resp2.StatusCode != http.StatusOK {\n+\t\tt.Errorf(\"Expected status code %d when serving stale cache, got %d\", http.StatusOK, resp2.StatusCode)\n+\t}\n+\n+\tbody := make([]byte, 8192)\n+\tn, _ := resp2.Body.Read(body)\n+\tbodyStr := string(body[:n])\n+\n+\t// Verify stale cache content is served\n+\tif !strings.Contains(bodyStr, \"Cached Channel\") {\n+\t\tt.Error(\"Expected stale cache content to be served\")\n+\t}\n+}","is_error":false}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"e4fabb5c-d8e9-4d64-bf15-7e66443a1c2d","tool_use_result":{"stdout":"diff --git a/main_test.go b/main_test.go\nindex 8c682f5..99c9cc6 100644\n--- a/main_test.go\n+++ b/main_test.go\n@@ -899,3 +899,678 @@ func TestIntegration_RealEndpoints(t *testing.T) {\n \t\t}\n \t})\n }\n+\n+// TestIntegration_UnifiedPlaylist_SuccessfulFetchAndMerge tests unified playlist endpoint\n+// with successful fetch and merge from both sources\n+func TestIntegration_UnifiedPlaylist_SuccessfulFetchAndMerge(t *testing.T) {\n+\tcacheDir, cleanup := setupTestEnvironment(t)\n+\tdefer cleanup()\n+\n+\t// Create mock content for elcano source\n+\telcanoContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"e1\" tvg-name=\"Elcano One\" tvg-logo=\"http://example.com/logo1.png\" group-title=\"Sports\",Elcano One\n+acestream://1111111111111111111111111111111111111111\n+#EXTINF:-1 tvg-id=\"e2\" tvg-name=\"Elcano Two\",Elcano Two\n+acestream://2222222222222222222222222222222222222222\n+`\n+\n+\t// Create mock content for newera source\n+\tneweraContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"NewEra One\" tvg-logo=\"http://example.com/logo2.png\",NewEra One\n+acestream://3333333333333333333333333333333333333333\n+#EXTINF:-1 tvg-id=\"n2\" tvg-name=\"NewEra Two\",NewEra Two\n+acestream://4444444444444444444444444444444444444444\n+`\n+\n+\t// Create mock servers\n+\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n+\tdefer elcanoServer.Close()\n+\n+\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n+\tdefer neweraServer.Close()\n+\n+\t// Initialize components\n+\tstorage, err := cache.NewFileStorage(cacheDir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n+\t}\n+\n+\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n+\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n+\n+\t// Create test server with unified endpoint\n+\tmux := http.NewServeMux()\n+\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n+\t\tif r.Method != http.MethodGet {\n+\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Fetch both sources\n+\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n+\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n+\n+\t\t// Check if both sources failed\n+\t\tif elcanoErr != nil && neweraErr != nil {\n+\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Build merged content\n+\t\tvar mergedContent strings.Builder\n+\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n+\n+\t\tif elcanoErr == nil {\n+\t\t\telcanoStr := string(elcanoContentBytes)\n+\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n+\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n+\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(elcanoStr)\n+\t\t}\n+\n+\t\tif neweraErr == nil {\n+\t\t\tneweraStr := string(neweraContentBytes)\n+\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n+\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n+\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n+\t\t\t}\n+\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n+\t\t\t\tmergedContent.WriteString(\"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(neweraStr)\n+\t\t}\n+\n+\t\t// Apply deduplication, sorting, and rewriting\n+\t\tmergedBytes := []byte(mergedContent.String())\n+\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n+\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n+\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write(rewrittenContent)\n+\t})\n+\n+\ttestServer := httptest.NewServer(mux)\n+\tdefer testServer.Close()\n+\n+\t// Make request\n+\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to make request: %v\", err)\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\tif resp.StatusCode != http.StatusOK {\n+\t\tt.Errorf(\"Expected status code %d, got %d\", http.StatusOK, resp.StatusCode)\n+\t}\n+\n+\tbody := make([]byte, 8192)\n+\tn, _ := resp.Body.Read(body)\n+\tbodyStr := string(body[:n])\n+\n+\t// Verify all streams from both sources are present\n+\tif !strings.Contains(bodyStr, \"Elcano One\") {\n+\t\tt.Error(\"Expected 'Elcano One' from elcano source\")\n+\t}\n+\tif !strings.Contains(bodyStr, \"Elcano Two\") {\n+\t\tt.Error(\"Expected 'Elcano Two' from elcano source\")\n+\t}\n+\tif !strings.Contains(bodyStr, \"NewEra One\") {\n+\t\tt.Error(\"Expected 'NewEra One' from newera source\")\n+\t}\n+\tif !strings.Contains(bodyStr, \"NewEra Two\") {\n+\t\tt.Error(\"Expected 'NewEra Two' from newera source\")\n+\t}\n+\n+\t// Verify URLs are rewritten\n+\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=1111111111111111111111111111111111111111\") {\n+\t\tt.Error(\"Expected rewritten URL for stream 1\")\n+\t}\n+\tif !strings.Contains(bodyStr, \"http://127.0.0.1:6878/ace/getstream?id=3333333333333333333333333333333333333333\") {\n+\t\tt.Error(\"Expected rewritten URL for stream 3\")\n+\t}\n+}\n+\n+// TestIntegration_UnifiedPlaylist_Deduplication tests that duplicate streams are removed\n+func TestIntegration_UnifiedPlaylist_Deduplication(t *testing.T) {\n+\tcacheDir, cleanup := setupTestEnvironment(t)\n+\tdefer cleanup()\n+\n+\t// Create mock content with duplicate acestream IDs\n+\telcanoContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"e1\" tvg-name=\"Channel A\",Channel A\n+acestream://1111111111111111111111111111111111111111\n+#EXTINF:-1 tvg-id=\"e2\" tvg-name=\"Channel B\",Channel B\n+acestream://2222222222222222222222222222222222222222\n+`\n+\n+\tneweraContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"Channel A Duplicate\",Channel A Duplicate\n+acestream://1111111111111111111111111111111111111111\n+#EXTINF:-1 tvg-id=\"n2\" tvg-name=\"Channel C\",Channel C\n+acestream://3333333333333333333333333333333333333333\n+`\n+\n+\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n+\tdefer elcanoServer.Close()\n+\n+\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n+\tdefer neweraServer.Close()\n+\n+\tstorage, err := cache.NewFileStorage(cacheDir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n+\t}\n+\n+\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n+\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n+\n+\tmux := http.NewServeMux()\n+\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n+\t\tif r.Method != http.MethodGet {\n+\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n+\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n+\n+\t\tif elcanoErr != nil && neweraErr != nil {\n+\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar mergedContent strings.Builder\n+\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n+\n+\t\tif elcanoErr == nil {\n+\t\t\telcanoStr := string(elcanoContentBytes)\n+\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n+\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n+\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(elcanoStr)\n+\t\t}\n+\n+\t\tif neweraErr == nil {\n+\t\t\tneweraStr := string(neweraContentBytes)\n+\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n+\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n+\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n+\t\t\t}\n+\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n+\t\t\t\tmergedContent.WriteString(\"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(neweraStr)\n+\t\t}\n+\n+\t\tmergedBytes := []byte(mergedContent.String())\n+\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n+\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n+\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write(rewrittenContent)\n+\t})\n+\n+\ttestServer := httptest.NewServer(mux)\n+\tdefer testServer.Close()\n+\n+\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to make request: %v\", err)\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\tbody := make([]byte, 8192)\n+\tn, _ := resp.Body.Read(body)\n+\tbodyStr := string(body[:n])\n+\n+\t// Count occurrences of the duplicate stream ID\n+\tduplicateCount := strings.Count(bodyStr, \"id=1111111111111111111111111111111111111111\")\n+\tif duplicateCount != 1 {\n+\t\tt.Errorf(\"Expected duplicate stream ID to appear once, but found %d occurrences\", duplicateCount)\n+\t}\n+\n+\t// Verify first occurrence is kept\n+\tif !strings.Contains(bodyStr, \"Channel A\") {\n+\t\tt.Error(\"Expected first occurrence 'Channel A' to be preserved\")\n+\t}\n+\n+\t// Verify duplicate is removed\n+\tif strings.Contains(bodyStr, \"Channel A Duplicate\") {\n+\t\tt.Error(\"Expected duplicate 'Channel A Duplicate' to be removed\")\n+\t}\n+\n+\t// Verify other unique streams are present\n+\tif !strings.Contains(bodyStr, \"Channel B\") {\n+\t\tt.Error(\"Expected 'Channel B' to be present\")\n+\t}\n+\tif !strings.Contains(bodyStr, \"Channel C\") {\n+\t\tt.Error(\"Expected 'Channel C' to be present\")\n+\t}\n+}\n+\n+// TestIntegration_UnifiedPlaylist_AlphabeticalSorting tests alphabetical sorting by display name\n+func TestIntegration_UnifiedPlaylist_AlphabeticalSorting(t *testing.T) {\n+\tcacheDir, cleanup := setupTestEnvironment(t)\n+\tdefer cleanup()\n+\n+\t// Create mock content with unsorted names\n+\telcanoContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"e1\",Zebra Channel\n+acestream://1111111111111111111111111111111111111111\n+#EXTINF:-1 tvg-id=\"e2\",Alpha Channel\n+acestream://2222222222222222222222222222222222222222\n+`\n+\n+\tneweraContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"n1\",Beta Channel\n+acestream://3333333333333333333333333333333333333333\n+#EXTINF:-1 tvg-id=\"n2\",Gamma Channel\n+acestream://4444444444444444444444444444444444444444\n+`\n+\n+\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n+\tdefer elcanoServer.Close()\n+\n+\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n+\tdefer neweraServer.Close()\n+\n+\tstorage, err := cache.NewFileStorage(cacheDir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n+\t}\n+\n+\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n+\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n+\n+\tmux := http.NewServeMux()\n+\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n+\t\tif r.Method != http.MethodGet {\n+\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n+\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n+\n+\t\tif elcanoErr != nil && neweraErr != nil {\n+\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar mergedContent strings.Builder\n+\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n+\n+\t\tif elcanoErr == nil {\n+\t\t\telcanoStr := string(elcanoContentBytes)\n+\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n+\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n+\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(elcanoStr)\n+\t\t}\n+\n+\t\tif neweraErr == nil {\n+\t\t\tneweraStr := string(neweraContentBytes)\n+\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n+\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n+\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n+\t\t\t}\n+\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n+\t\t\t\tmergedContent.WriteString(\"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(neweraStr)\n+\t\t}\n+\n+\t\tmergedBytes := []byte(mergedContent.String())\n+\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n+\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n+\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write(rewrittenContent)\n+\t})\n+\n+\ttestServer := httptest.NewServer(mux)\n+\tdefer testServer.Close()\n+\n+\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to make request: %v\", err)\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\tbody := make([]byte, 8192)\n+\tn, _ := resp.Body.Read(body)\n+\tbodyStr := string(body[:n])\n+\n+\t// Find positions of channel names\n+\talphaPos := strings.Index(bodyStr, \"Alpha Channel\")\n+\tbetaPos := strings.Index(bodyStr, \"Beta Channel\")\n+\tgammaPos := strings.Index(bodyStr, \"Gamma Channel\")\n+\tzebraPos := strings.Index(bodyStr, \"Zebra Channel\")\n+\n+\t// Verify alphabetical order\n+\tif alphaPos == -1 || betaPos == -1 || gammaPos == -1 || zebraPos == -1 {\n+\t\tt.Fatal(\"Not all channels found in response\")\n+\t}\n+\n+\tif !(alphaPos < betaPos && betaPos < gammaPos && gammaPos < zebraPos) {\n+\t\tt.Errorf(\"Channels not in alphabetical order. Positions: Alpha=%d, Beta=%d, Gamma=%d, Zebra=%d\",\n+\t\t\talphaPos, betaPos, gammaPos, zebraPos)\n+\t}\n+}\n+\n+// TestIntegration_UnifiedPlaylist_LogoRemoval tests that tvg-logo attributes are removed\n+func TestIntegration_UnifiedPlaylist_LogoRemoval(t *testing.T) {\n+\tcacheDir, cleanup := setupTestEnvironment(t)\n+\tdefer cleanup()\n+\n+\telcanoContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"e1\" tvg-logo=\"http://example.com/logo1.png\" tvg-name=\"Channel One\",Channel One\n+acestream://1111111111111111111111111111111111111111\n+`\n+\n+\tneweraContent := `#EXTM3U\n+#EXTINF:-1 tvg-id=\"n1\" tvg-name=\"Channel Two\" tvg-logo=\"http://example.com/logo2.png\",Channel Two\n+acestream://2222222222222222222222222222222222222222\n+`\n+\n+\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n+\tdefer elcanoServer.Close()\n+\n+\tneweraServer := createMockIPFSServer(t, false, neweraContent)\n+\tdefer neweraServer.Close()\n+\n+\tstorage, err := cache.NewFileStorage(cacheDir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n+\t}\n+\n+\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n+\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n+\n+\tmux := http.NewServeMux()\n+\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n+\t\tif r.Method != http.MethodGet {\n+\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n+\t\tneweraContentBytes, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n+\n+\t\tif elcanoErr != nil && neweraErr != nil {\n+\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar mergedContent strings.Builder\n+\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n+\n+\t\tif elcanoErr == nil {\n+\t\t\telcanoStr := string(elcanoContentBytes)\n+\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n+\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n+\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(elcanoStr)\n+\t\t}\n+\n+\t\tif neweraErr == nil {\n+\t\t\tneweraStr := string(neweraContentBytes)\n+\t\t\tif strings.HasPrefix(neweraStr, \"#EXTM3U\") {\n+\t\t\t\tneweraStr = strings.TrimPrefix(neweraStr, \"#EXTM3U\")\n+\t\t\t\tneweraStr = strings.TrimLeft(neweraStr, \"\\n\")\n+\t\t\t}\n+\t\t\tif mergedContent.Len() > len(\"#EXTM3U\\n\") {\n+\t\t\t\tmergedContent.WriteString(\"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(neweraStr)\n+\t\t}\n+\n+\t\tmergedBytes := []byte(mergedContent.String())\n+\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n+\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n+\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write(rewrittenContent)\n+\t})\n+\n+\ttestServer := httptest.NewServer(mux)\n+\tdefer testServer.Close()\n+\n+\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to make request: %v\", err)\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\tbody := make([]byte, 8192)\n+\tn, _ := resp.Body.Read(body)\n+\tbodyStr := string(body[:n])\n+\n+\t// Verify logos are removed\n+\tif strings.Contains(bodyStr, \"tvg-logo=\") {\n+\t\tt.Error(\"Expected tvg-logo attributes to be removed\")\n+\t}\n+\tif strings.Contains(bodyStr, \"logo1.png\") {\n+\t\tt.Error(\"Expected logo1.png to be removed\")\n+\t}\n+\tif strings.Contains(bodyStr, \"logo2.png\") {\n+\t\tt.Error(\"Expected logo2.png to be removed\")\n+\t}\n+\n+\t// Verify other metadata is preserved\n+\tif !strings.Contains(bodyStr, \"tvg-id=\\\"e1\\\"\") {\n+\t\tt.Error(\"Expected tvg-id to be preserved\")\n+\t}\n+\tif !strings.Contains(bodyStr, \"tvg-name=\\\"Channel One\\\"\") {\n+\t\tt.Error(\"Expected tvg-name to be preserved\")\n+\t}\n+}\n+\n+// TestIntegration_UnifiedPlaylist_NetworkCachingParameter tests network-caching parameter in URLs\n+func TestIntegration_UnifiedPlaylist_NetworkCachingParameter(t *testing.T) {\n+\tcacheDir, cleanup := setupTestEnvironment(t)\n+\tdefer cleanup()\n+\n+\telcanoContent := `#EXTM3U\n+#EXTINF:-1,Test Channel\n+acestream://1111111111111111111111111111111111111111\n+`\n+\n+\telcanoServer := createMockIPFSServer(t, false, elcanoContent)\n+\tdefer elcanoServer.Close()\n+\n+\tneweraServer := createMockIPFSServer(t, true, \"\") // Failing server\n+\tdefer neweraServer.Close()\n+\n+\tstorage, err := cache.NewFileStorage(cacheDir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n+\t}\n+\n+\tfetch := fetcher.New(5*time.Second, storage, 1*time.Hour)\n+\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n+\n+\tmux := http.NewServeMux()\n+\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n+\t\tif r.Method != http.MethodGet {\n+\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n+\t\t_, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n+\n+\t\tif elcanoErr != nil && neweraErr != nil {\n+\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar mergedContent strings.Builder\n+\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n+\n+\t\tif elcanoErr == nil {\n+\t\t\telcanoStr := string(elcanoContentBytes)\n+\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n+\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n+\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(elcanoStr)\n+\t\t}\n+\n+\t\tmergedBytes := []byte(mergedContent.String())\n+\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n+\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n+\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write(rewrittenContent)\n+\t})\n+\n+\ttestServer := httptest.NewServer(mux)\n+\tdefer testServer.Close()\n+\n+\tresp, err := http.Get(testServer.URL + \"/playlist.m3u\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to make request: %v\", err)\n+\t}\n+\tdefer resp.Body.Close()\n+\n+\tbody := make([]byte, 8192)\n+\tn, _ := resp.Body.Read(body)\n+\tbodyStr := string(body[:n])\n+\n+\t// Verify network-caching parameter is present\n+\tif !strings.Contains(bodyStr, \"network-caching=1000\") {\n+\t\tt.Error(\"Expected network-caching=1000 parameter in rewritten acestream URLs\")\n+\t}\n+\n+\t// Verify complete URL format\n+\texpectedURL := \"http://127.0.0.1:6878/ace/getstream?id=1111111111111111111111111111111111111111&network-caching=1000\"\n+\tif !strings.Contains(bodyStr, expectedURL) {\n+\t\tt.Errorf(\"Expected URL with network-caching parameter: %s\", expectedURL)\n+\t}\n+}\n+\n+// TestIntegration_UnifiedPlaylist_CacheFallback tests cache fallback when sources fail\n+func TestIntegration_UnifiedPlaylist_CacheFallback(t *testing.T) {\n+\tcacheDir, cleanup := setupTestEnvironment(t)\n+\tdefer cleanup()\n+\n+\telcanoContent := `#EXTM3U\n+#EXTINF:-1,Cached Channel\n+acestream://1111111111111111111111111111111111111111\n+`\n+\n+\telcanoAvailable := true\n+\telcanoServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tif !elcanoAvailable {\n+\t\t\tw.WriteHeader(http.StatusServiceUnavailable)\n+\t\t\treturn\n+\t\t}\n+\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write([]byte(elcanoContent))\n+\t}))\n+\tdefer elcanoServer.Close()\n+\n+\tneweraServer := createMockIPFSServer(t, true, \"\") // Always failing\n+\tdefer neweraServer.Close()\n+\n+\tstorage, err := cache.NewFileStorage(cacheDir)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create storage: %v\", err)\n+\t}\n+\n+\tfetch := fetcher.New(5*time.Second, storage, 100*time.Millisecond) // Short TTL\n+\trw := rewriter.New(\"http://127.0.0.1:6878/ace/getstream\")\n+\n+\tmux := http.NewServeMux()\n+\tmux.HandleFunc(\"/playlist.m3u\", func(w http.ResponseWriter, r *http.Request) {\n+\t\tif r.Method != http.MethodGet {\n+\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n+\t\t\treturn\n+\t\t}\n+\n+\t\telcanoContentBytes, _, _, elcanoErr := fetch.FetchWithCache(elcanoServer.URL)\n+\t\t_, _, _, neweraErr := fetch.FetchWithCache(neweraServer.URL)\n+\n+\t\tif elcanoErr != nil && neweraErr != nil {\n+\t\t\thttp.Error(w, \"Bad Gateway\", http.StatusBadGateway)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar mergedContent strings.Builder\n+\t\tmergedContent.WriteString(\"#EXTM3U\\n\")\n+\n+\t\tif elcanoErr == nil {\n+\t\t\telcanoStr := string(elcanoContentBytes)\n+\t\t\tif strings.HasPrefix(elcanoStr, \"#EXTM3U\") {\n+\t\t\t\telcanoStr = strings.TrimPrefix(elcanoStr, \"#EXTM3U\")\n+\t\t\t\telcanoStr = strings.TrimLeft(elcanoStr, \"\\n\")\n+\t\t\t}\n+\t\t\tmergedContent.WriteString(elcanoStr)\n+\t\t}\n+\n+\t\tmergedBytes := []byte(mergedContent.String())\n+\t\tdeduplicatedContent := rewriter.DeduplicateStreams(mergedBytes)\n+\t\tsortedContent := rewriter.SortStreamsByName(deduplicatedContent)\n+\t\trewrittenContent := rw.RewriteM3U(sortedContent)\n+\n+\t\tw.Header().Set(\"Content-Type\", \"audio/x-mpegurl\")\n+\t\tw.WriteHeader(http.StatusOK)\n+\t\tw.Write(rewrittenContent)\n+\t})\n+\n+\ttestServer := httptest.NewServer(mux)\n+\tdefer testServer.Close()\n+\n+\t// First request - populate cache\n+\tresp1, err := http.Get(testServer.URL + \"/playlist.m3u\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to make first request: %v\", err)\n+\t}\n+\tresp1.Body.Close()\n+\n+\tif resp1.StatusCode != http.StatusOK {\n+\t\tt.Errorf(\"Expected status code %d for first request, got %d\", http.StatusOK, resp1.StatusCode)\n+\t}\n+\n+\t// Wait for cache to expire\n+\ttime.Sleep(150 * time.Millisecond)\n+\n+\t// Make elcano unavailable\n+\telcanoAvailable = false\n+\n+\t// Second request - should serve stale cache\n+\tresp2, err := http.Get(testServer.URL + \"/playlist.m3u\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to make second request: %v\", err)\n+\t}\n+\tdefer resp2.Body.Close()\n+\n+\tif resp2.StatusCode != http.StatusOK {\n+\t\tt.Errorf(\"Expected status code %d when serving stale cache, got %d\", http.StatusOK, resp2.StatusCode)\n+\t}\n+\n+\tbody := make([]byte, 8192)\n+\tn, _ := resp2.Body.Read(body)\n+\tbodyStr := string(body[:n])\n+\n+\t// Verify stale cache content is served\n+\tif !strings.Contains(bodyStr, \"Cached Channel\") {\n+\t\tt.Error(\"Expected stale cache content to be served\")\n+\t}\n+}","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01SSH1EQL1Lf7Mqdx4Hdhohy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011fXPgNkBhxP4tT7AJkuFbT","name":"Bash","input":{"command":"git add main_test.go && git commit -m \"$(cat <<'EOF'\nfeat: US-007 - Add integration tests for unified playlist endpoint\n\nCo-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>\nEOF\n)\"","description":"Commit the integration tests"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":9313,"cache_read_input_tokens":75090,"cache_creation":{"ephemeral_5m_input_tokens":9313,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"6e63eefa-01e7-4416-87ac-2df9229542c1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011fXPgNkBhxP4tT7AJkuFbT","type":"tool_result","content":"[main cfa7803] feat: US-007 - Add integration tests for unified playlist endpoint\n 1 file changed, 675 insertions(+)","is_error":false}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"888745ad-daeb-4150-a54a-a3016bf50adf","tool_use_result":{"stdout":"[main cfa7803] feat: US-007 - Add integration tests for unified playlist endpoint\n 1 file changed, 675 insertions(+)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TiVwLndwtnJRBCTUDnjbp3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TYeSiLN5QnkZADuSgBqJfQ","name":"TodoWrite","input":{"todos":[{"content":"Examine existing test patterns in main_test.go","activeForm":"Examining existing test patterns in main_test.go","status":"completed"},{"content":"Review the unified playlist endpoint implementation","activeForm":"Reviewing the unified playlist endpoint implementation","status":"completed"},{"content":"Write integration tests covering all acceptance criteria","activeForm":"Writing integration tests covering all acceptance criteria","status":"completed"},{"content":"Run go build ./... to verify build","activeForm":"Running go build ./... to verify build","status":"completed"},{"content":"Run go test ./... to verify all tests pass","activeForm":"Running go test ./... to verify all tests pass","status":"completed"},{"content":"Commit changes with feat message","activeForm":"Committing changes with feat message","status":"completed"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":185,"cache_read_input_tokens":84403,"cache_creation":{"ephemeral_5m_input_tokens":185,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"09833f4e-f104-496d-bdfc-916ca79a487b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TYeSiLN5QnkZADuSgBqJfQ","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"ea896846-b73c-4023-a051-8380b8bc6b3c","tool_use_result":{"oldTodos":[{"content":"Examine existing test patterns in main_test.go","status":"completed","activeForm":"Examining existing test patterns in main_test.go"},{"content":"Review the unified playlist endpoint implementation","status":"completed","activeForm":"Reviewing the unified playlist endpoint implementation"},{"content":"Write integration tests covering all acceptance criteria","status":"completed","activeForm":"Writing integration tests covering all acceptance criteria"},{"content":"Run go build ./... to verify build","status":"completed","activeForm":"Running go build ./... to verify build"},{"content":"Run go test ./... to verify all tests pass","status":"completed","activeForm":"Running go test ./... to verify all tests pass"},{"content":"Commit changes with feat message","status":"in_progress","activeForm":"Committing changes with feat message"}],"newTodos":[{"content":"Examine existing test patterns in main_test.go","status":"completed","activeForm":"Examining existing test patterns in main_test.go"},{"content":"Review the unified playlist endpoint implementation","status":"completed","activeForm":"Reviewing the unified playlist endpoint implementation"},{"content":"Write integration tests covering all acceptance criteria","status":"completed","activeForm":"Writing integration tests covering all acceptance criteria"},{"content":"Run go build ./... to verify build","status":"completed","activeForm":"Running go build ./... to verify build"},{"content":"Run go test ./... to verify all tests pass","status":"completed","activeForm":"Running go test ./... to verify all tests pass"},{"content":"Commit changes with feat message","status":"completed","activeForm":"Committing changes with feat message"}]}}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01NyTmS8HEXckGsLwVtSNo5H","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! I've successfully completed US-007. Here's a summary of what was implemented:\n\n## Summary\n\nI added comprehensive integration tests for the unified playlist endpoint (`/playlist.m3u`) that cover all acceptance criteria:\n\n### Tests Implemented:\n\n1. **TestIntegration_UnifiedPlaylist_SuccessfulFetchAndMerge** (main_test.go:904)\n   - Tests successful fetch and merge from both elcano and newera sources\n   - Verifies all streams from both sources are present in the merged output\n   - Confirms URL rewriting is applied correctly\n\n2. **TestIntegration_UnifiedPlaylist_Deduplication** (main_test.go:1036)\n   - Tests deduplication behavior with duplicate acestream IDs\n   - Verifies first occurrence is kept and duplicates are removed\n   - Confirms only one instance of duplicate IDs appears in output\n\n3. **TestIntegration_UnifiedPlaylist_AlphabeticalSorting** (main_test.go:1139)\n   - Tests alphabetical sorting by display name\n   - Verifies channels appear in correct alphabetical order (Alpha → Beta → Gamma → Zebra)\n\n4. **TestIntegration_UnifiedPlaylist_LogoRemoval** (main_test.go:1235)\n   - Tests that tvg-logo attributes are removed from all streams\n   - Verifies other metadata (tvg-id, tvg-name) is preserved\n\n5. **TestIntegration_UnifiedPlaylist_NetworkCachingParameter** (main_test.go:1320)\n   - Tests presence of network-caching parameter in acestream URLs\n   - Verifies complete URL format includes `&network-caching=1000`\n\n6. **TestIntegration_UnifiedPlaylist_CacheFallback** (main_test.go:1393)\n   - Tests cache fallback behavior when sources fail\n   - Verifies stale cache is served when fresh content unavailable\n\n### Quality Checks:\n- ✅ `go build ./...` passes\n- ✅ `go test ./...` passes (all tests completed successfully in 0.501s)\n- ✅ Tests follow existing patterns in main_test.go\n- ✅ All acceptance criteria covered\n\n<promise>COMPLETE</promise>"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":300,"cache_read_input_tokens":84588,"cache_creation":{"ephemeral_5m_input_tokens":300,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","uuid":"a54f8f8b-7135-4d66-99d6-5c380d3dd447"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":184935,"duration_api_ms":186155,"num_turns":17,"result":"Perfect! I've successfully completed US-007. Here's a summary of what was implemented:\n\n## Summary\n\nI added comprehensive integration tests for the unified playlist endpoint (`/playlist.m3u`) that cover all acceptance criteria:\n\n### Tests Implemented:\n\n1. **TestIntegration_UnifiedPlaylist_SuccessfulFetchAndMerge** (main_test.go:904)\n   - Tests successful fetch and merge from both elcano and newera sources\n   - Verifies all streams from both sources are present in the merged output\n   - Confirms URL rewriting is applied correctly\n\n2. **TestIntegration_UnifiedPlaylist_Deduplication** (main_test.go:1036)\n   - Tests deduplication behavior with duplicate acestream IDs\n   - Verifies first occurrence is kept and duplicates are removed\n   - Confirms only one instance of duplicate IDs appears in output\n\n3. **TestIntegration_UnifiedPlaylist_AlphabeticalSorting** (main_test.go:1139)\n   - Tests alphabetical sorting by display name\n   - Verifies channels appear in correct alphabetical order (Alpha → Beta → Gamma → Zebra)\n\n4. **TestIntegration_UnifiedPlaylist_LogoRemoval** (main_test.go:1235)\n   - Tests that tvg-logo attributes are removed from all streams\n   - Verifies other metadata (tvg-id, tvg-name) is preserved\n\n5. **TestIntegration_UnifiedPlaylist_NetworkCachingParameter** (main_test.go:1320)\n   - Tests presence of network-caching parameter in acestream URLs\n   - Verifies complete URL format includes `&network-caching=1000`\n\n6. **TestIntegration_UnifiedPlaylist_CacheFallback** (main_test.go:1393)\n   - Tests cache fallback behavior when sources fail\n   - Verifies stale cache is served when fresh content unavailable\n\n### Quality Checks:\n- ✅ `go build ./...` passes\n- ✅ `go test ./...` passes (all tests completed successfully in 0.501s)\n- ✅ Tests follow existing patterns in main_test.go\n- ✅ All acceptance criteria covered\n\n<promise>COMPLETE</promise>","session_id":"f98efcc9-282b-4438-a078-ec6ef94a8f42","total_cost_usd":0.732436,"usage":{"input_tokens":79,"cache_creation_input_tokens":49276,"cache_read_input_tokens":1024555,"output_tokens":14948,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":49276}},"modelUsage":{"claude-sonnet-4-5-20250929":{"inputTokens":79,"outputTokens":14948,"cacheReadInputTokens":1024555,"cacheCreationInputTokens":49276,"webSearchRequests":0,"costUSD":0.7166085000000001,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":3395,"outputTokens":182,"cacheReadInputTokens":0,"cacheCreationInputTokens":9218,"webSearchRequests":0,"costUSD":0.0158275,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[],"uuid":"bf091899-c9f8-4cbd-b3ca-faa119347e55"}
